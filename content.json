{"meta":{"title":"耿瑞阳的博客","subtitle":null,"description":"今天最好的表现，是明天最低的要求。","author":"Geng","url":"https://Gengry.github.io"},"pages":[{"title":"关于","date":"2018-01-22T14:36:05.000Z","updated":"2018-03-26T06:22:37.402Z","comments":false,"path":"about/index.html","permalink":"https://Gengry.github.io/about/index.html","excerpt":"","text":"今天最好的表现，是明天最低的要求。"},{"title":"categories","date":"2018-01-22T14:32:07.000Z","updated":"2018-03-26T06:22:37.402Z","comments":false,"path":"categories/index.html","permalink":"https://Gengry.github.io/categories/index.html","excerpt":"","text":""},{"title":"时间轴","date":"2018-03-26T06:22:37.404Z","updated":"2018-03-26T06:22:37.404Z","comments":true,"path":"timeline/index.html","permalink":"https://Gengry.github.io/timeline/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-01-22T14:31:16.000Z","updated":"2018-03-26T06:22:37.403Z","comments":false,"path":"tags/index.html","permalink":"https://Gengry.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"安装单机hadoop-linux虚拟机配置","slug":"安装单机hadoop-linux虚拟机配置","date":"2018-04-05T03:38:36.000Z","updated":"2018-04-05T13:36:34.993Z","comments":true,"path":"2018/04/05/安装单机hadoop-linux虚拟机配置/","link":"","permalink":"https://Gengry.github.io/2018/04/05/安装单机hadoop-linux虚拟机配置/","excerpt":"伪分布模式安装步骤 关闭防火墙 修改ip 修改hostname 设置ssh自动登录 安装jdk 安装hadoop","text":"伪分布模式安装步骤 关闭防火墙 修改ip 修改hostname 设置ssh自动登录 安装jdk 安装hadoop 防火墙CentOS 6.5关闭防火墙[root@localhost ~]#servcie iptables stop –临时关闭防火墙[root@localhost ~]#chkconfig iptables off –永久关闭防火墙 CentOS 7.2关闭防火墙CentOS 7.0默认使用的是firewall作为防火墙，这里改为iptables防火墙步骤。firewall-cmd –state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）[root@localhost ~]#firewall-cmd –statenot running systemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动 修改ip vim /etc/sysconfig/network-script/ifcfg-eth0BOOTPROTO=staticIPADDR=192.168.137.3NETMASK=255.255.255.0GATEWAY=192.168.137.1DNS1=8.8.8.8DNS2=8.8.4.4 安装jdk下载linux版的jdk，使用xshell上传到虚拟机。 tar -zxvf jdk-7u80-linux-x64.tar.gz mv jdk1.7.0_80/ /usr/local/ vim /etc/profileexport JAVA_HOME=/usr/local/jdk1.7.0_80 export JRE_HOME=/usr/local/jdk1.7.0_80/jre export PATH=$PATH:/usr/local/jdk1.7.0_80/bin export CLASSPATH=./:/usr/local/jdk1.7.0_80/lib:/usr/local/jdk1.7.0_80/jre/lib 1.准备Linux环境 1.0点击VMware快捷方式，右键打开文件所在位置 -&gt; 双击vmnetcfg.exe -&gt; VMnet1 host-only -&gt;修改subnet ip 设置网段：192.168.1.0 子网掩码：255.255.255.0 -&gt; apply -&gt; ok 回到windows –&gt; 打开网络和共享中心 -&gt; 更改适配器设置 -&gt; 右键VMnet1 -&gt; 属性 -&gt; 双击IPv4 -&gt; 设置windows的IP：192.168.1.110 子网掩码：255.255.255.0 -&gt; 点击确定 在虚拟软件上 –My Computer -&gt; 选中虚拟机 -&gt; 右键 -&gt; settings -&gt; network adapter -&gt; host only -&gt; ok 1.1修改主机名 vim /etc/sysconfig/network NETWORKING=yes HOSTNAME=itcast01 ### 1.2修改IP 两种方式： 第一种：通过Linux图形界面进行修改（强烈推荐） 进入Linux图形界面 -&gt; 右键点击右上方的两个小电脑 -&gt; 点击Edit connections -&gt; 选中当前网络System eth0 -&gt; 点击edit按钮 -&gt; 选择IPv4 -&gt; method选择为manual -&gt; 点击add按钮 -&gt; 添加IP：192.168.1.119 子网掩码：255.255.255.0 网关：192.168.1.1 -&gt; apply 第二种：修改配置文件方式（屌丝程序猿专用） vim /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE=&quot;eth0&quot; BOOTPROTO=&quot;static&quot; ### HWADDR=&quot;00:0C:29:3C:BF:E7&quot; IPV6INIT=&quot;yes&quot; NM_CONTROLLED=&quot;yes&quot; ONBOOT=&quot;yes&quot; TYPE=&quot;Ethernet&quot; UUID=&quot;ce22eeca-ecde-4536-8cc2-ef0dc36d4a8c&quot; IPADDR=&quot;192.168.1.44&quot; ### NETMASK=&quot;255.255.255.0&quot; ### GATEWAY=&quot;192.168.1.1&quot; ### 1.3修改主机名和IP的映射关系 vim /etc/hosts 192.168.1.44 itcast01 1.4关闭防火墙 #查看防火墙状态 service iptables status #关闭防火墙 service iptables stop #查看防火墙开机启动状态 chkconfig iptables --list #关闭防火墙开机启动 chkconfig iptables off 1.5重启Linux reboot 2.安装JDK 2.1上传 2.2解压jdk #创建文件夹 mkdir /usr/java #解压 tar -zxvf jdk-7u55-linux-i586.tar.gz -C /usr/java/ 2.3将java添加到环境变量中 vim /etc/profile #在文件最后添加 export JAVA_HOME=/usr/java/jdk1.7.0_55 export PATH=$PATH:$JAVA_HOME/bin #刷新配置 source /etc/profile 3.安装Hadoop 3.1上传hadoop安装包 3.2解压hadoop安装包 mkdir /cloud #解压到/cloud/目录下 tar -zxvf hadoop-2.2.0.tar.gz -C /cloud/ 3.3修改配置文件（5个） 第一个：hadoop-env.sh #在27行修改 export JAVA_HOME=/usr/java/jdk1.7.0_55 第二个：core-site.xml &lt;configuration&gt; &lt;!-- 指定HDFS老大（namenode）的通信地址 --&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://itcast01:9000&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定hadoop运行时产生文件的存储路径 --&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/cloud/hadoop-2.2.0/tmp&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 第三个：hdfs-site.xml &lt;configuration&gt; &lt;!-- 设置hdfs副本数量 --&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 第四个：mapred-site.xml.template 需要重命名： mv mapred-site.xml.template mapred-site.xml &lt;configuration&gt; &lt;!-- 通知框架MR使用YARN --&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 第五个：yarn-site.xml &lt;configuration&gt; &lt;!-- reducer取数据的方式是mapreduce_shuffle --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 3.4将hadoop添加到环境变量 vim /etc/profile export JAVA_HOME=/usr/java/jdk1.7.0_55 export HADOOP_HOME=/cloud/hadoop-2.2.0 export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin source /etc/profile 3.5格式化HDFS（namenode）第一次使用时要格式化 hadoop namenode -format 3.6启动hadoop 先启动HDFS sbin/start-dfs.sh 再启动YARN sbin/start-yarn.sh 3.7验证是否启动成功 使用jps命令验证 27408 NameNode 28218 Jps 27643 SecondaryNameNode 28066 NodeManager 27803 ResourceManager 27512 DataNode http://192.168.1.44:50070 (HDFS管理界面) 在这个文件中添加linux主机名和IP的映射关系 C:\\Windows\\System32\\drivers\\etc\\hosts 192.168.1.119 itcast http://192.168.1.44:8088 （MR管理界面） 4.配置ssh免登陆 生成ssh免登陆密钥 cd ~，进入到我的home目录 cd .ssh/ ssh-keygen -t rsa （四个回车） 执行完这个命令后，会生成两个文件id_rsa（私钥）、id_rsa.pub（公钥） 将公钥拷贝到要免登陆的机器上 cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 或 ssh-copy-id -i localhost 5.hdfs基本使用 1.0查看帮助 hadoop fs -help &lt;cmd&gt; 1.1上传 hadoop fs -put &lt;linux上文件&gt; &lt;hdfs上的路径&gt; 1.2查看文件内容 hadoop fs -cat &lt;hdfs上的路径&gt; 1.3查看文件列表 hadoop fs -ls / 1.4下载文件 hadoop fs -get &lt;hdfs上的路径&gt; &lt;linux上文件&gt; 6.MapReduce示例 hadoop为我们提供了mr的示例程序，存放在/hadoop/hadoop-2.2.0/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.2.0.jar 安装hadoop2.4.1 注意：hadoop2.x的配置文件$HADOOP_HOME/etc/hadoop 伪分布式需要修改5个配置文件 3.1配置hadoop 第一个：hadoop-env.sh vim hadoop-env.sh #第27行 export JAVA_HOME=/usr/java/jdk1.7.0_65 第二个：core-site.xml &lt;!-- 制定HDFS的老大（NameNode）的地址 --&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://itcast01:9000&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定hadoop运行时产生文件的存储目录 --&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/itcast/hadoop-2.4.1/tmp&lt;/value&gt; &lt;/property&gt; 第三个：hdfs-site.xml &lt;!-- 指定HDFS副本的数量 --&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; 第四个：mapred-site.xml (mv mapred-site.xml.template mapred-site.xml) mv mapred-site.xml.template mapred-site.xml vim mapred-site.xml &lt;!-- 指定mr运行在yarn上 --&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; 第五个：yarn-site.xml &lt;!-- 指定YARN的老大（ResourceManager）的地址 --&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;itcast01&lt;/value&gt; &lt;/property&gt; &lt;!-- reducer获取数据的方式 --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; 3.2将hadoop添加到环境变量 vim /etc/proflie export JAVA_HOME=/usr/java/jdk1.7.0_65 export HADOOP_HOME=/itcast/hadoop-2.4.1 export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin source /etc/profile 3.3格式化namenode（是对namenode进行初始化） hdfs namenode -format (hadoop namenode -format) 3.4启动hadoop 先启动HDFS sbin/start-dfs.sh 再启动YARN sbin/start-yarn.sh 3.5验证是否启动成功 使用jps命令验证 27408 NameNode 28218 Jps 27643 SecondaryNameNode 28066 NodeManager 27803 ResourceManager 27512 DataNode http://192.168.8.118:50070 （HDFS管理界面） http://192.168.8.118:8088 （MR管理界面） 遇到的问题启动hdfs，datanode无法启动。可以看到datanode日志文件报错hadoop-root-datanode-localhost.localdomain.logorg.apache.hadoop.ipc.RemoteException(org.apache.hadoop.hdfs.server.protocol.DisallowedDatanodeException): Datanode denied communication with namenode: DatanodeRegistration(0.0.0.0, storageID=DS-1492551125-127.0.0.1-50010-1522922793693, infoPort=50075, ipcPort=50020, storageInfo=lv=-47;cid=CID-0a985653-165f-4fed-8366-d5552fe4abd9;nsid=150074941;c=0) at org.apache.hadoop.hdfs.server.blockmanagement.DatanodeManager.registerDatanode(DatanodeManager.java:739) 解决： 修改hosts文件 vim /etc/hosts 添加 192.168.138.3 localhost解决办法二： 在namenode的hdfs-site.xml 里面添加 1234&lt;property&gt; &lt;name&gt;dfs.namenode.datanode.registration.ip-hostname-check&lt;/name&gt; &lt;value&gt;false&lt;/value&gt;&lt;/property&gt; 网上给出的错误原因：错误和原来的hosts中的“127.0.0.1 localhost”没有关系，是增加了的“192.168.1.101 localhost”解决了问题。原因在于RSA没有给局域网ip（192.168.1.101）授权，造成data node没有正常启动。 项目启动后http://192.168.137.3:50070页面内的`Browse the filesystem`无法访问 解决： 点击Browse the filesystem浏览器中的地址栏为http://localhost:50075/browseDirectory.jsp?namenodeInfoPort=50070&amp;dir=/&amp;nnaddr=192.168.137.3:9000 很明显是地址不对，但是用鼠标指着Browse the filesystem显示的地址是对的，说明在browseDirectory.jsp做了一次页面跳转。 将地址手动修改为192.168.137.3:50075后可以正常访问。 猜测： browseDirectory.jsp这个页面内namenode随机选择了一个datanode的地址做跳转，对于namenode来说，单机模式的datanode地址就是localhost。 我自己配置的时候并没有配置主机名，主机默认就是localhost。 修改： 配置主机名 vim /etc/sysconfig/network NETWORKING=yes HOSTNAME=gengry ### 配置主机名和ip对应关系 vim /etc/hosts 192.168.137.3 gengry 配置windows的hosts 192.168.137.3 gengry 重启hadoop，再次访问，正常。 今天最好的表现，是明天最低的要求。","categories":[],"tags":[]},{"title":"Java多线程--三个线程分别打印a,b,c.请用多线程实现循环打印15次abc","slug":"Java多线程-三个线程分别打印a-b-c-请用多线程实现循环打印15次abc","date":"2018-03-26T06:25:32.000Z","updated":"2018-03-26T06:27:01.650Z","comments":true,"path":"2018/03/26/Java多线程-三个线程分别打印a-b-c-请用多线程实现循环打印15次abc/","link":"","permalink":"https://Gengry.github.io/2018/03/26/Java多线程-三个线程分别打印a-b-c-请用多线程实现循环打印15次abc/","excerpt":"Java多线程–三个线程分别打印a,b,c.请用多线程实现循环打印15次abc","text":"Java多线程–三个线程分别打印a,b,c.请用多线程实现循环打印15次abc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * Created by CHG on 2017-02-23 20:20. */public class PrintABC &#123; int count = 0; //打印次数 Lock lock = new ReentrantLock(); //可重写锁 Condition conditionA = this.lock.newCondition(); Condition conditionB = this.lock.newCondition(); Condition conditionC = this.lock.newCondition(); public class PrintA implements Runnable &#123; @Override public void run() &#123; while (true) if (count &lt; 15) &#123; lock.lock(); System.out.print(\"A\"); try &#123; conditionB.signal(); //线程b唤醒,因为a打印完应该打印b conditionA.await(); //线程a进入等待队列 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; &#125; public class PrintB implements Runnable &#123; @Override public void run() &#123; while (true) if (count &lt; 15) &#123; lock.lock(); System.out.print(\"B\"); try &#123; conditionC.signal(); conditionB.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; &#125; public class PrintC implements Runnable &#123; @Override public void run() &#123; while (true) if (count &lt; 15) &#123; lock.lock(); System.out.println(\"C\" + count); count++;//打印完c后,count++ try &#123; conditionA.signal(); conditionC.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; PrintABC printABCD = new PrintABC(); new Thread(printABCD.new PrintA()).start(); new Thread(printABCD.new PrintB()).start(); new Thread(printABCD.new PrintC()).start(); &#125;&#125; 今天最好的表现，是明天最低的要求。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-03-26T06:22:37.400Z","updated":"2018-03-26T06:22:37.401Z","comments":true,"path":"2018/03/26/hello-world/","link":"","permalink":"https://Gengry.github.io/2018/03/26/hello-world/","excerpt":"","text":"1234567public class highlight&#123; public static void main(String args[]) &#123; System.out.println(\"Highlight\"); &#125;&#125;","categories":[],"tags":[]},{"title":"JDK并发包","slug":"JDK并发包","date":"2018-02-22T02:44:02.000Z","updated":"2018-03-26T06:22:37.400Z","comments":true,"path":"2018/02/22/JDK并发包/","link":"","permalink":"https://Gengry.github.io/2018/02/22/JDK并发包/","excerpt":"同步工具","text":"同步工具 ReentranLock高版本的jdk中已经对synchronized做了足够多的优化，普通的场景下它的性能已经非常接近ReentrantLock。所以一些简单的场景不必过分纠结这两者之间的性能问题。下面这个例子反而使用synchronized的耗时小于使用ReentrantLock。 可重入123456789101112131415161718192021222324252627282930313233343536373839public class ReenterLock implements Runnable &#123; //可重入锁的使用 public static ReentrantLock lock = new ReentrantLock(); public static int i = 0; @Override public void run() &#123; for(int j=0; j&lt;1000000;j++)&#123; //加锁 lock.lock(); try&#123; i++; &#125;finally &#123; //释放锁 lock.unlock(); &#125; &#125; &#125;/* @Override public void run() &#123; for(int j=0; j&lt;1000000;j++) &#123; synchronized (this)&#123; i++; &#125; &#125; &#125;*/ public static void main(String[] args) throws InterruptedException &#123; long time1 = System.currentTimeMillis(); ReenterLock tl = new ReenterLock(); Thread t1 = new Thread(tl); Thread t2 = new Thread(tl); t1.start();t2.start(); t1.join();t2.join(); long time2 = System.currentTimeMillis(); System.out.println(i); System.out.println(time2-time1); &#125;&#125; 如果在一个线程中多次使用了加锁操作，就需要有对应数量的释放锁操作。 123456789101112131415@Override public void run() &#123; for(int j=0; j&lt;1000000;j++)&#123; //加锁 lock.lock(); lock.lock(); try&#123; i++; &#125;finally &#123; //释放锁 lock.unlock(); lock.unlock(); &#125; &#125; &#125; 下面我们加两次锁，只释放一次锁执行一下。1234567891011121314@Override public void run() &#123; for(int j=0; j&lt;1000000;j++)&#123; //加锁 lock.lock(); lock.lock(); try&#123; i++; &#125;finally &#123; //释放锁 lock.unlock(); &#125; &#125; &#125; 就会发现程序卡住了，一直没有执行结束我们通过使用jdk的两个命令来看看发生了什么通过jps获取到这个进程的id通过jstack看看这个进程的栈信息可以看到Thread-1处于waiting状态一直在等在某种条件，就是等待另一个线程释放锁。所在了第13行，也就是lock.lock(); 可中断在加锁的同时可以去响应中断，如果发生了死锁，或者意料之外的情况，在一个锁上卡了很久，还是有办法把这个线程唤醒，不至于永久性的卡死下去。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ReenterLockInt implements Runnable &#123; public static ReentrantLock lock1 = new ReentrantLock(); public static ReentrantLock lock2 = new ReentrantLock(); int lock; /* * 控制加锁顺序，方便构成死锁 * */ public ReenterLockInt(int lock)&#123; this.lock = lock; &#125; @Override public void run() &#123; try&#123; if(lock == 1)&#123; lock1.lockInterruptibly(); //代表可中断的加锁 try&#123; Thread.sleep(500); &#125;catch (InterruptedException e)&#123;&#125; lock2.lockInterruptibly(); &#125;else&#123; lock2.lockInterruptibly(); try&#123; Thread.sleep(500); &#125;catch (InterruptedException e)&#123;&#125; lock1.lockInterruptibly(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; if(lock1.isHeldByCurrentThread())&#123; lock1.unlock(); &#125; if(lock2.isHeldByCurrentThread())&#123; lock2.unlock(); &#125; System.out.println(Thread.currentThread().getId()+\":线程退出。\"); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; ReenterLockInt r1 = new ReenterLockInt(1); ReenterLockInt r2 = new ReenterLockInt(2); Thread t1 = new Thread(r1); Thread t2 = new Thread(r2); t1.start();t2.start(); Thread.sleep(1000); &#125;&#125; 上面这段代码，发生了死锁，程序无法正常结束。通过jstack可以看到发现了一个死锁。 实现是个守护线程，来触发死锁后的中断 1234567891011121314151617181920212223242526272829303132public class DeadLockChecker &#123; private final static ThreadMXBean mbean = ManagementFactory.getThreadMXBean(); final static Runnable deadlockCheck = new Runnable() &#123; @Override public void run() &#123; while (true)&#123; long[] deadlockedThreadIds = mbean.findDeadlockedThreads(); if(deadlockedThreadIds != null)&#123; ThreadInfo[] threadInfos = mbean.getThreadInfo(deadlockedThreadIds); for (Thread t : Thread.getAllStackTraces().keySet())&#123; for(int i = 0;i&lt;threadInfos.length; i++)&#123; if(t.getId() == threadInfos[i].getThreadId())&#123; t.interrupt(); &#125; &#125; &#125; &#125; try &#123; Thread.sleep(5000); &#125;catch (InterruptedException e)&#123; &#125; &#125; &#125; &#125;; public static void check()&#123; Thread t = new Thread(deadlockCheck); t.setDaemon(true); //设置为守护线程 t.start(); &#125;&#125; 1234567891011public static void main(String[] args) throws InterruptedException &#123; ReenterLockInt r1 = new ReenterLockInt(1); ReenterLockInt r2 = new ReenterLockInt(2); Thread t1 = new Thread(r1); Thread t2 = new Thread(r2); t1.start();t2.start(); Thread.sleep(1000); //开启死锁检测 DeadLockChecker.check(); &#125; 可限时使用lock.trylock(5,TimeUtil.SECOND)的方式获取锁。可以设置一个时间阈值，可以避免无限等待。 123456789101112131415161718192021222324252627public class TimeLock implements Runnable&#123; public static ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123; try&#123; if(lock.tryLock(5, TimeUnit.SECONDS))&#123; System.out.println(Thread.currentThread().getId()+\":get lock successed\"); Thread.sleep(6000); &#125;else&#123; System.out.println(Thread.currentThread().getId()+\":get lock failed\"); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; if(lock.isHeldByCurrentThread())&#123; lock.unlock(); &#125; &#125; &#125; public static void main(String[] args) &#123; TimeLock tl = new TimeLock(); Thread t1 = new Thread(tl); Thread t2 = new Thread(tl); t1.start(); t2.start(); &#125;&#125; 公平锁公平锁会保证获取锁的先到先得。公平锁不会产生饥饿问题，但是公平锁的性能要差很多，默认是非公平的。可以通过构造方法指定为公平锁。 Condition概念类似于Object.wait()和Object.notify()与ReentrantLock结合使用。Condition的执行方式，是当在线程1中调用await方法后，线程1将释放锁，并且将自己沉睡，等待唤醒，线程2获取到锁后，开始做事，完毕后，调用Condition的signal方法，唤醒线程1，线程1恢复执行。 主要接口 1234567891011121314151617181920212223242526public class ReenterLockCondition implements Runnable &#123; public static ReentrantLock lock = new ReentrantLock(); public static Condition condition = lock.newCondition(); @Override public void run() &#123; try&#123; lock.lock(); condition.await(); System.out.println(\"Thread is going on\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; ReenterLockCondition tl = new ReenterLockCondition(); Thread t1 = new Thread(tl); t1.start(); Thread.sleep(2000); lock.lock(); condition.signal(); lock.unlock(); &#125;&#125; APIawait()方法会使当前线程等待，同时释放当前锁，当其他线程使用signal()时或者signalAll()方法时，线程会重新或得锁并继续执行。或者当线程中断时，也能跳出等待，这和Object.wait()方法类似。awaitUninterruptibly() 和 await()基本相同，但是它并不会在等待的过程中响应中断。signal()方法用于唤醒一个等待中的线程，相对的signalAll会唤醒所有等待中的线程，和Object.notify()类似。 Semaphore 信号量锁是排他的，临界区只能有一个线程占用。信号量是一种共享锁，信号量是许可若干个线程进入临界区，超过许可的上线就必须等待。如果信号量的许可线程为1，就可以当成是排他锁。 1234567891011121314151617181920212223public class SemapDemo implements Runnable&#123; final Semaphore semp = new Semaphore(5); @Override public void run() &#123; try&#123; semp.acquire(); Thread.sleep(2000); System.out.println(Thread.currentThread().getId()+\":done\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; semp.release(); &#125; &#125; public static void main(String[] args) &#123; ExecutorService exec = Executors.newFixedThreadPool(20); final SemapDemo semapDemo = new SemapDemo(); for (int i=0; i&lt;20; i++)&#123; exec.submit(semapDemo); &#125; &#125;&#125; 主要接口acquire()acquireUninterruptibly()tryAcquire()tryAcquire(long timeout, TimeUnit unit)release() ReadWriteLock加锁之后，并行度就降为1，只有一个线程可以进入。我们需要通过操作对访问临界区的行为进行划分，当几个线程都是读取数据时，我们是不需要加锁的。 ReadWriteLock中的read线程都是无等待的并发。ReadWriteLock的实现ReentrantReadWriteLock，使用方法和ReentrantLock类似。12public ReentrantReadWriteLock.WriteLock writeLock() &#123; return writerLock; &#125;public ReentrantReadWriteLock.ReadLock readLock() &#123; return readerLock; &#125; CountDownLatch概念倒数计时器一种典型的场景就是火箭发射器，在火箭发射前，为了保证万无一失，往往需要对各个设备、仪表进行检查，它是一个点火线程，等待所有检查完工后，再执行。 主要接口static final CountDownLatch end = new CountDownLatch(10);end.countDown();end.await(); 线程完成既定目标后执行end.countDown();当计数器为零后 等待的主线程end.await() 继续执行。 123456789101112131415161718192021222324252627public class CountDownLatchDemo implements Runnable &#123; static final CountDownLatch end = new CountDownLatch(10); static final CountDownLatchDemo demo = new CountDownLatchDemo(); @Override public void run() &#123; try &#123; //模拟检查任务 Thread.sleep(new Random().nextInt(10)*1000); System.out.println(\"check complete\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; end.countDown(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; ExecutorService exec = Executors.newFixedThreadPool(10); for(int i=0; i&lt;10; i++)&#123; exec.submit(demo); &#125; //等待检查 end.await(); //发射火箭 System.out.println(\"fire!\"); exec.shutdown(); &#125;&#125; CyclicBarrier相当于一个循环的CountDownLatch 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class CyclicBarrierDemo &#123; public static class Solder implements Runnable&#123; private String soldier; private final CyclicBarrier cyclic; Solder(CyclicBarrier cyclic,String soldierName)&#123; this.cyclic = cyclic; this.soldier = soldierName; &#125; @Override public void run() &#123; try&#123; cyclic.await(); doWork(); cyclic.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; finally &#123; &#125; &#125; void doWork()&#123; try&#123; Thread.sleep(Math.abs(new Random().nextInt()%10000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(soldier+\":任务完成\"); &#125; &#125; public static class BarrierRun implements Runnable&#123; boolean flag; int N; public BarrierRun( boolean flag,int N)&#123; this.flag = flag; this.N = N; &#125; @Override public void run() &#123; if(flag)&#123; System.out.println(\"司令：[士兵\"+N+\"个，任务完成！]\"); &#125;else&#123; System.out.println(\"司令：[士兵\"+N+\"个，集合完成！]\"); flag = true; &#125; &#125; &#125; public static void main(String[] args) &#123; final int N = 10; Thread[] allSoldier = new Thread[N]; boolean flag = false; CyclicBarrier cyclic = new CyclicBarrier(N,new BarrierRun(flag,N)); System.out.println(\"集合队伍！\"); for(int i=0;i&lt;N;i++)&#123; System.out.println(\"士兵\"+i+\"报道！\"); allSoldier[i] = new Thread(new Solder(cyclic,\"士兵\"+i)); allSoldier[i].start();// if(i==5)&#123;// allSoldier[0].interrupt();// &#125; &#125; &#125;&#125; LockSupport提供线程阻塞原语。 主要接口LockSupport.park();LockSupport.unpark(); 今天最好的表现，是明天最低的要求。","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://Gengry.github.io/categories/Java并发编程/"}],"tags":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://Gengry.github.io/tags/Java并发编程/"}]},{"title":"高并发网站中的数据库设计","slug":"高并发网站中的数据库设计","date":"2018-02-09T00:42:22.000Z","updated":"2018-03-26T06:22:37.399Z","comments":true,"path":"2018/02/09/高并发网站中的数据库设计/","link":"","permalink":"https://Gengry.github.io/2018/02/09/高并发网站中的数据库设计/","excerpt":"介绍数据库其实就是一个普通的计算机系统，为我们提供某种服务。我们对数据库功能的抽闲可以将数据库功能抽象成三个部分","text":"介绍数据库其实就是一个普通的计算机系统，为我们提供某种服务。我们对数据库功能的抽闲可以将数据库功能抽象成三个部分 用户API 关系代数和事物引擎 K-V存储 关系型数据库底层也是K-V模型的，但是他为我们提供了更高层的服务，这些服务牺牲了运算速度实现了原子性，一致性，隔离性。但是有些时候我们需要效率，关系型数据库成了系统的瓶颈。我们需要把速度拿回来，所以一些K-V数据库就产生了，其实就是去掉了关系代数和事物引擎将K-V存储和关于K-V的API暴露给了用户,这就是Nosql，Nosql放弃了事物提高了速度。但是人们发现最简单的K-V存储好像什么事情都干不了，需要我们处理的事情太多了，就产生了newSql，为我们处理了关系代数模型和事物引擎的一部分功能。 Key-Value存储本质就是映射，按照key找value。 映射的关键特性 扩展 是否支持范围查找 是否能够处理更新 读写性能指标 是否面向磁盘结构 并行指标 内存占用 Etc… 常见的数据结构 排序数组 排序链表 跳表 B tree LSM tree HashMap Fractal Tree Red-Black-tree COLA Etc… 关系代数primary key:id user_id name 按照key找value， Primary Key:id 按照id查找其他数据。 但是如果按照user_id查看记录，则需要遍历所有记录。效率为O(n) 二级索引二级索引就是同样也是个K-V映射表 key为user_id,value为主键id。如果二级索引为Hash结构，效率就下降为0(1),如果是二分查找 Tree，效率为O(logN)这样查询 先按user_id查找到id，在通过id查找到数据。 如果按照多条件查询 where user_id = 1 and name = ‘tom’如果按照刚才的索引查找，但是如果user_id为1的记录有一万条，我们就需要遍历一万条记录。 组合索引扩展阅读扩展阅读使用 user_id和name作为key，主键id作为value。 事物简介事物的核心是锁和并发 优势：方便理解 劣势：性能较低 事物其实就是帮助程序员人脑来理解程序到底是怎么运转的。人脑永远是串行的。把一个逻辑整理成第一步，第二步，第三步…但是这要的程序只能在单机单线程中执行。而现实生活中很多事情都是有先后的，例如我们从bob账户中取钱，我们查询账户余额为100，但我们真的去做减的时候，bob账户中的钱已经被别人取走了。人脑不能很好的理解并发的概念，所以就设计了一种模式，就是事物，让我们方便理解并发，但是降低了性能。 容易理解的模型性能都不好，性能好的模型都不容易理解 – 这就是生活。 事物单元其实数据库的DDL操作都可以拆分成两个操作，insert 是先查询再插入，update 先查询再更新， delete 先查询再删除，只有select是一个查询操作。每次查询的时候都把数据锁上，锁的概念：在线程上面维持一个对这个访问的独占权，其他线程不能再访问它了。事物所覆盖的所有数据都会被这个线程独占。但是如果都用这么重量级的锁，那性能就太低了，所以事物为我们提供了四种隔离界别 未提交读 提交读 可重复读 序列化 这些也是单独的事物单元 商品要建立一个基于GMT_Modified的索引 从数据库中读取一行记录 向数据库中写入一行记录，同事更新这行记录的所有索引 删除整张表 Etc… 一组事物单元，是顺序执行的，第一个事物单元结束后，第二个事物单元才开始执行。如果两个事物单元没有任何关系的话，A事物操作bob账户，B事物操作tom账户，两个事物是可以并行的。如果两个事物共享同一份数据，事物没有办法并行。 事物产生原因扩展阅读 事物单元之间的Happen-before关系（数据的四种冲突） 读写 写度 读读 写写 问题 如何能以最快的速度完成 又能保证上面四种操作的逻辑顺序 mvcc Multi-Version Concurrency Control 多版本并发控制 SQL引擎现在主流的数据库都在使用CBO（基于成本的优化）进行系统的操作。 分布式存储多级K-V存储关键特性 可运维 高性能 可以比较容易的扩容 核心数据结构还是hash和树，部分case针对多机做了一点优化。 代表性组件 mongoDB -&gt; mongos服务器 Hbase -&gt; region server + client jar包 DRDS(TDDL) -&gt; tddl规则引擎组件 分布式结构可以理解成map套map的过程，先查询数据在哪个单机，再做单机查询。 路由规则引擎：有状态的数据应该按照什么规则进行写入和读取例如：对pk % 3 —&gt; DB0,DB1,DB2 本质来说还是个查找的过程 hash O(1)效率 不支持范围查询（按时间这样的查询条件就比较困难） 不需要频繁调整数据分布 Tree 主要是 B Tree O(logN)效率 支持范围查询 需要频繁分裂和合并 Hash Id%n 最普通的hash 如果id%3 -&gt; id%4 总共会走80%的数据发生移动，最好的情况是倍分id%3 -&gt; id%6,这时候会有50%的数据发生移动 数据移动本身就是个要了亲命的事 hash 一致性hash 只要解决数据的扩容和缩容的问题 虚拟节点 解决热点问题，只需要调整对应关系疾苦 解决n-&gt;n+1问题，规则可以规定只移动需要移动的数据 方案相对复杂 一般推荐使用简单方案开始，使用n-&gt;2n方案扩容 只有需要的情况下，在考虑平滑的扩展到虚拟节点方案。 B-Tree Hbase使用的切分方法 支持范围查询 对于发部分场景来说，引导列都是pk.userid一类的单值查询，用树相对复杂。 需要频繁的进行切分和合并操作 –region server的恶梦 固定节点情况下，跨度相对较大，查询效率可能会进一步降低 一致性寻求一种能够保证，在给定多台计算机，并且他们相互之间由网络相互连通，中间的数据没有拜占庭将军问题（数据不会被伪造）的前提下（P Partition tolerance 分区容忍性）能够做到一下两种特性的方法： 数据的每次成功写入，数据不会丢失，并且按照写入的顺序排列 （C Consistency 一致性） 给定安全级别，保证服务的可用性，并尽可能减少机器的消耗（A Availability 可用性） 数据的可用性 服务的可用性 （响应时间，例如500ms） 无主机方案 Dynamo/cassandra/Paxos:gossip ,W+R&gt;N (W&gt;N-R) N(node) w(write) r(read) 所有节点可写，不存在单点故障 读数据的最新版本，需要将所有节点的数据都读出来合并一次 有主机方案（Raft）主从配置 Mysql MongoDB Oracle+fibreChannel 只有一个节点可写，切换时存在短暂leader election过程，会出现短暂不可写。 数据一致性比较好控制，读最新数据只需要读主机就可以，一致性读性能较好。 实际系统需要考虑的问题 有些机器负担写任务，因此读压力可能不均衡，因此必须有权重设置。 单个节点挂掉的时候，TCP超时会导致业务APP的线程花费更多的时间来处理单个请求，这样会降低APP的处理能力，导致雪崩。 因为突发情况，导致数据库请求书增加，数据库相应变慢，导致雪崩。 数据库实践 单机优化原则 二分查找效率&gt;全表遍历 选择合适的索引 内存读写&gt;SSD读写&gt;磁盘读写 将物理读（磁盘读）换成逻辑读（内存读） 减少锁冲突 尽可能通过业务设计，将更新变成插入，来减少加锁去锁的操作 减少临时表使用 减少多维度排序 分布式系统优化原则 减少跨机网络交互 尽可能带sharding key 分页优化（google一下） 减少数据读写热点 切分颗粒度尽可能细（用户颗粒度好于省份） 减少锁开销 尽可能规避分布式事物 总结沈询所有资源的索引（会不断更新） 尽一切可能利用单机资源 单机事物 单机join 好的存储模型 尽可能走内存 尽可能将以此要查询到的数据物理的放在一起 通过合理的数据冗余，减少走网络的次数 合理并行提升响应时间 读取数据瓶颈，可以通过加slave节点解决 写入瓶颈，用规则sharding和扩容来解决 警惕 InnoDB 和 MyISAM 创建 Hash 索引陷阱 今天最好的表现，是明天最低的要求。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://Gengry.github.io/categories/数据库/"}],"tags":[{"name":"事物","slug":"事物","permalink":"https://Gengry.github.io/tags/事物/"},{"name":"数据库","slug":"数据库","permalink":"https://Gengry.github.io/tags/数据库/"}]},{"title":"虚拟机安装Centos，安装mysql，配置主从（三）","slug":"虚拟机安装Centos，安装mysql，配置主从（三）","date":"2018-02-08T02:47:14.000Z","updated":"2018-03-26T06:22:37.399Z","comments":true,"path":"2018/02/08/虚拟机安装Centos，安装mysql，配置主从（三）/","link":"","permalink":"https://Gengry.github.io/2018/02/08/虚拟机安装Centos，安装mysql，配置主从（三）/","excerpt":"","text":"今天最好的表现，是明天最低的要求。","categories":[],"tags":[]},{"title":"一个十二年老程序猿的碎碎念（转）","slug":"一个十二年老程序猿的碎碎念（转）","date":"2018-02-08T02:31:09.000Z","updated":"2018-03-26T06:22:37.398Z","comments":true,"path":"2018/02/08/一个十二年老程序猿的碎碎念（转）/","link":"","permalink":"https://Gengry.github.io/2018/02/08/一个十二年老程序猿的碎碎念（转）/","excerpt":"我是一名程序猿，在95年上初中的时候，别人还都在打篮球、踢足球的时候，我就已经在玩QBasic了，每逢跟其他程序猿说起这段的时候，大家都会投过来羡慕的眼光，其实没有你们想的那么好，反而挺悲催的，当时的同学们都不知道我在说些啥，另外我至今都不会打篮球、踢足球。果然不出意外（不会有意外的，我大学填报的所有志愿都是计算机系）的大学毕业后做了一枚程序猿。","text":"我是一名程序猿，在95年上初中的时候，别人还都在打篮球、踢足球的时候，我就已经在玩QBasic了，每逢跟其他程序猿说起这段的时候，大家都会投过来羡慕的眼光，其实没有你们想的那么好，反而挺悲催的，当时的同学们都不知道我在说些啥，另外我至今都不会打篮球、踢足球。果然不出意外（不会有意外的，我大学填报的所有志愿都是计算机系）的大学毕业后做了一枚程序猿。工作到现在有十二个年头了，大部分工作都是做开发，当然也做过些别的，干过销售，跟朋友合伙创业等等，不过我依然还是喜欢做开发。 就在工作2年，写了2年程序的时候，我觉得自己太蔫儿了，程序猿嘛，更愿意低头做事而不是抬头说话，于是决定辞职去做了半年多销售，就为了练练嘴。现在我还清晰地记得打第一个推销电话的时候，我提前写好了稿子，紧张得面红耳赤，拨通电话就照着稿子念，等我念完了发现对方早挂了。不过就这样一点点地磨过来了，拿了个年度销售冠军，然后毅然辞职，又跑去写程序了。乔丹曾说过：“如果没有去打棒球的话，都不知道自己有多么地爱篮球”。我也借用这句话：如果没有跑去做销售的话，都不知道自己有多么地爱代码。 我算是比较幸运，把自己的爱好作为了职业，可以亲手将一个产品从无到有地打造出来的喜悦感还是非常满足的。虽然很多时候都是解决需求、改bug这些枯燥的事情吧，这就好像你喜欢玩游戏，但是职业化地一遍又一遍地重复一个游戏也是很郁闷的。我还有一个爱好就是摄影，我绝不去做职业摄影师，保持这个爱好就是爱好，纯玩儿。 曾有一个段子说：一个妹子问一个程序猿如何让一帮不爱说话的程序猿活跃起来，那个程序猿说了一句PHP是最好的语言。。。很多程序猿都喜欢站队，所谓站队就是自己在玩某某语言的时候，就会觉得这个语言很强大，自然而然地就站了队了。 我们的身边充斥着写java的看不上写.net的，写c的看不上一切，node异军突起，python批评ruby垃圾性能，高富帅swift从天而降，PHP是最强语言等等。。。 十二年前，我刚工作的时候，写医疗软件，用VB写界面，用VC写功能封装dll，当时觉得VB，VC太强了，结果现在它们基本都死了。 同样的还有： 我写过Dephi，死了。。 我写过asp，死了。。 我写过塞班，死了。。 我们更应当做的是跳出语言的框框，编程注重的是思想，而非语言。 有人不屑于C#的lambda表达式，认为这就是个语法糖。其实你可以把它看作为将冗余的循环判断重构为一句话，IT行业很多时候都是在给其他行业做提升效率的工作，轮到我们自己为啥就不能提升下开发效率呢，程序猿挺苦逼了，吃块糖咋了？ 有人不屑于.net的闭源，但是微软正在把很多.net的东西开源了，反观oracle跟Google的java官司有一种oracle要玩死java的赶脚啊。 有人不屑于java的呆板，但是java不计其数的开源框架支撑这个古老而又现代的帝国。 有人不屑于js就是个脚本，但是node异军突起，正在逐步向后端深入。 跳出语言的框框吧，作为一枚程序猿，我们更应该重视的并不是语言本身，语言只是一个工具罢了。 有一篇鸡汤说：两个人在工地搬砖，有人问他们你们在干嘛，一个说我在搬砖，另一个说我在建造大楼。几年后说搬砖的人还在搬砖，而说建造大楼的人通过进修一点点做到工程师了。 这虽然是一篇鸡汤，但是确实说明白了一个道理，就是你的思想决定了你的行动，影响了你的结果。当然对于程序猿更是如此了，因为我们是码农，没了思想就是一个搬砖的。 举个例子：如果有一天pm告诉你，要做一个朋友圈这样的产品，你会怎么做？ 初级程序员会怎么做？ 1、建立用户表、用户朋友圈发的内容表、点赞评价表，然后做表表关联。 高级一点的程序猿还会想到什么？ 2、图片要做压缩吧，现在手机动不动1000多w像素，一张图片好几m，不压缩的话先不说服务器压力，用户刷新一下朋友圈这个月的流量就没了的话，一定会马上删应用骂街的。 3、图片要分布式存储吧，CDN引入的问题。 4、辣么多表做关联，响应的问题，并发的问题，缓存怎么搞。 5、数据量大了的话，分库拆库是否要提前计划好。 6、发朋友圈要有消息通知吗？如何做？ 7、数据量大了之后用多表关联的方式是否还合适？ 还有一些也许pm并没有说到的细节呢？ 8、朋友圈一定就是9张图片吗，以后会不会要求增加呢，当年微博还要求必须140个字呢，现在也没限制了，如果你数据表只是设计了9个图片字段的话。。。 9、图片是否要预留加入ps、美颜等功能的考虑呢？ 10、用户选择图片的时候是否可以多选，选择图片的列表是不是应该按照时间倒序排列？ 11、pm只说了发朋友圈，那么修改删除呢？ 12、评论、点赞修改了删除呢？删除后已发出的消息怎么办？ 如果你只考虑第1的话，那么不好意思，你就是在搬砖呢。 如果你考虑了2-7的话，恭喜你是一个合格的程序猿。 只有考虑到了8-12，才是那个不仅仅在搬砖的程序猿。 有人会说了8-12这些应该是pm做的事情啊，pm没说就不做啊。还是那句话，如果pm告诉你什么你就做什么的话，那就是在搬砖，只是在完成工作罢了，而不是在打造一款真正的产品。 以上，就是我这个十二年的老程序猿的碎碎念。 作者：williamnet链接：https://www.jianshu.com/p/072b262cd089来源：简书 今天最好的表现，是明天最低的要求。","categories":[],"tags":[]},{"title":"nginx+tomcat负载均衡，在nginx层配置http、https转http到tomcat，jsp协议和端口号不对应问题","slug":"nginx-tomcat负载均衡，在nginx层配置http、https转http到tomcat，jsp协议和端口号不对应问题","date":"2018-02-07T06:18:20.000Z","updated":"2018-03-26T06:22:37.397Z","comments":true,"path":"2018/02/07/nginx-tomcat负载均衡，在nginx层配置http、https转http到tomcat，jsp协议和端口号不对应问题/","link":"","permalink":"https://Gengry.github.io/2018/02/07/nginx-tomcat负载均衡，在nginx层配置http、https转http到tomcat，jsp协议和端口号不对应问题/","excerpt":"问题描述App端部分功能使用h5页面实现，但是偶尔用户反映会有广告。也就是请求被第三方劫持了插入了广告，所以决定全业务切https。在nginx配置https将https的请求转发的tomcat的http端口。但是发现一个问题就是h5页面的资源和ajax请求失败，原因是url中的协议和端口号不对应。","text":"问题描述App端部分功能使用h5页面实现，但是偶尔用户反映会有广告。也就是请求被第三方劫持了插入了广告，所以决定全业务切https。在nginx配置https将https的请求转发的tomcat的http端口。但是发现一个问题就是h5页面的资源和ajax请求失败，原因是url中的协议和端口号不对应。1String basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\"; 结果是协议为http，端口号为 https的端口号，导致静态资源加载、ajax请求失败。http://****:6443/**** 无法请求到服务器。 解决问题nginx配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475upstream ******&#123; server 127.0.0.1:8680 weight=1 fail_timeout=600s; server 127.0.0.1:8980 weight=1; &#125; server &#123; listen 80; server_name *******; charset utf-8; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; #root html; #index index.html index.htm; #proxy_pass **********; proxy_redirect off; proxy_set_header Host $host; proxy_set_header Host $host:80; #proxy_set_header X-Real-IP $remote_addr; #proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; client_body_buffer_size 128k; proxy_connect_timeout 300; proxy_send_timeout 300; proxy_read_timeout 300; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; access_log logs/access_http.log; &#125; server &#123; listen 6443 ssl; server_name **********; error_log /usr/local/nginx/logs/error_debug debug; ssl_certificate /usr/local/nginx/ssl/pn.crt; ssl_certificate_key /usr/local/nginx/ssl/pn.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; #add_header From /; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-Proto https; proxy_redirect off; proxy_connect_timeout 240; proxy_send_timeout 240; proxy_read_timeout 240; # proxy_pass *********; # proxy_set_header Host $http_host; # proxy_set_header X-Real-IP $remote_addr; # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # proxy_set_header Cookie $http_cookie; # client_max_body_size 1000m; &#125; access_log logs/apkaccess.log; &#125; tomcat server.xml配置在tomcat的标签中加入123456&lt;Valve className=\"org.apache.catalina.valves.RemoteIpValve\" remoteIpHeader=\"x-forwarded-for\" remoteIpProxiesHeader=\"x-forwarded-by\" protocolHeader=\"x-forwarded-proto\" httpsServerPort=\"6443\" /&gt; 解释分析nginx中的核心配置为,这几项配置，会在请求头中设置这几个参数。1234proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; 我们随便写一个接口，获取请求头。123456@RequestMapping(value = \"/ggggggg\",method=RequestMethod.GET)@ResponseBodypublic Object ggggggg( HttpServletRequest request) throws ParseException &#123; Enumeration enumeration = request.getHeaderNames(); return null;&#125; 经过debug我们可以看到 request的请求头中已经加入了这几个参数 配置tomcat后可以查看request获取的协议和端口号信息。 tomcat的配置文件其实就是指定tomcat如何将http请求包装成request对象。我们打开tomcat的api看一看RemoteIpValve这个类。tomcat API public class RemoteIpValveextends ValveBaseTomcat port of mod_remoteip, this valve replaces the apparent client remote IP address and hostname for the request with the IP address list presented by a proxy or a load balancer via a request headers (e.g. “X-Forwarded-For”).Another feature of this valve is to replace the apparent scheme (http/https) and server port with the scheme presented by a proxy or a load balancer via a request header (e.g. “X-Forwarded-Proto”). 这样tomcat会从请求头中获取这几个参数，实例化request。如果https走的是443端口则不用设置 httpsServerPort默认值为443。我这里https走的是6443，所以需要配置。 参考文档 http://blog.csdn.net/vfush/article/details/51086274https://www.cnblogs.com/gentoo/archive/2012/10/13/2722463.htmlhttp://blog.csdn.net/newtelcom/article/details/50782950http://blog.csdn.net/RKun595/article/details/71012484 今天最好的表现，是明天最低的要求。","categories":[{"name":"nginx","slug":"nginx","permalink":"https://Gengry.github.io/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://Gengry.github.io/tags/nginx/"},{"name":"tomcat","slug":"tomcat","permalink":"https://Gengry.github.io/tags/tomcat/"}]},{"title":"sourcetree免登陆授权","slug":"sourcetree免登陆授权","date":"2018-02-07T05:51:03.000Z","updated":"2018-03-26T06:22:37.398Z","comments":true,"path":"2018/02/07/sourcetree免登陆授权/","link":"","permalink":"https://Gengry.github.io/2018/02/07/sourcetree免登陆授权/","excerpt":"git桌面客户端sourcetree需要注册登录，但是sourcetree官网注册的验证码是走的google，国内无法完成注册。","text":"git桌面客户端sourcetree需要注册登录，但是sourcetree官网注册的验证码是走的google，国内无法完成注册。安装后修改配置文件：C:\\Users\\lenovo\\AppData\\Local\\Atlassian\\SourceTree\\accounts.json123456789101112131415161718192021222324[ &#123; \"$id\": \"1\", \"$type\": \"SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity\", \"Authenticate\": true, \"HostInstance\": &#123; \"$id\": \"2\", \"$type\": \"SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount\", \"Host\": &#123; \"$id\": \"3\", \"$type\": \"SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount\", \"Id\": \"atlassian account\" &#125;, \"BaseUrl\": \"https://id.atlassian.com/\" &#125;, \"Credentials\": &#123; \"$id\": \"4\", \"$type\": \"SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account\", \"Username\": \"\", \"Email\": null &#125;, \"IsDefault\": false &#125;] 今天最好的表现，是明天最低的要求。","categories":[{"name":"工具","slug":"工具","permalink":"https://Gengry.github.io/categories/工具/"}],"tags":[{"name":"sourcetree","slug":"sourcetree","permalink":"https://Gengry.github.io/tags/sourcetree/"}]},{"title":"虚拟机安装Centos，安装mysql，配置主从（二）","slug":"虚拟机安装Centos，安装mysql，配置主从（二）","date":"2018-02-06T04:59:41.000Z","updated":"2018-03-26T06:22:37.396Z","comments":true,"path":"2018/02/06/虚拟机安装Centos，安装mysql，配置主从（二）/","link":"","permalink":"https://Gengry.github.io/2018/02/06/虚拟机安装Centos，安装mysql，配置主从（二）/","excerpt":"下载mysql仍然使用中国科学技术大学镜像站下载mysql。最新版本的mysql。这里下载的mysql是二进制包，没有使用linux的包管理工具。","text":"下载mysql仍然使用中国科学技术大学镜像站下载mysql。最新版本的mysql。这里下载的mysql是二进制包，没有使用linux的包管理工具。 阅读mysql安装文档通过百度打开mysql的官网，找到mysql5.7GA的文档。 1234567891011121314shell&gt; groupadd mysqlshell&gt; useradd -r -g mysql -s /bin/false mysqlshell&gt; cd /usr/localshell&gt; tar zxvf /path/to/mysql-VERSION-OS.tar.gzshell&gt; ln -s full-path-to-mysql-VERSION-OS mysqlshell&gt; cd mysqlshell&gt; mkdir mysql-filesshell&gt; chown mysql:mysql mysql-filesshell&gt; chmod 750 mysql-filesshell&gt; bin/mysqld --initialize --user=mysql shell&gt; bin/mysql_ssl_rsa_setup shell&gt; bin/mysqld_safe --user=mysql &amp;# Next command is optionalshell&gt; cp support-files/mysql.server /etc/init.d/mysql.server 安装使用xshell工具通过ssh连接到centos，ssh协议支持xftp协议，可以将本地的文件上传到虚拟机中的centos中。 创建用户及相关将mysql目录及其子目录的所有者设置为mysql 12345678910mv mysql-5.7.21-linux-glibc2.12-x86_64 mysqlcd /usr/localln -s /home/mysql/mysql mysqlcd /home/mysqlmkdir mysql-datamkdir mysql-logsmkdir mysql-tmpchown mysql:mysql -R mysql/# 初始化mysql的data文件夹[root@localhost mysql]# ./bin/mysqld --initialize --user=mysql --basedir=/home/mysql/mysql --datadir=/home/mysql/mysql-data mysql配置文件将下面的配置复制到 /etc/my.cnf中1234567891011121314151617181920212223[client]default_character_set = utf8port = 3306#这个路径需要和mysqld中socket的路径相同socket = /tmp/mysql.sock[mysqld]basedir = /home/mysql/mysqldatadir = /home/mysql/mysql-datauser = mysqlport = 3306server_id = 1character_set_server = utf8socket = /tmp/mysql.sockpid-file = /tmp/mysql.pidlog-bin = /home/mysql/mysql-logs/bin_log # 二进制日志，用户主从复制relay-log = /home/mysql/mysql-logs/relay_log #从mysql的IO thread将主的bin_log复制到这个文件log-error = /home/mysql/mysql-logs/mysql_error.logexplicit_defaults_for_timestamp = trueexpire_logs_days = 10max_binlog_size = 100Mbinlog-do-db = #复制数据库名称binlog-ignore-db = mysql #忽略二进制日志的数据库名 配置启动脚本1shell&gt; cp support-files/mysql.server /etc/init.d/mysql.server 启动mysql1service mysql start 报错MySQL.2018-02-06T06:07:04.427707Z mysqld_safe error: log-error set to &#39;/home/mysql/mysql-logs/mysql_error.log&#39;, however file don&#39;t exists. Create writable for user &#39;mysql&#39; 需要手动建立error_log文件12touch /home/mysql/mysql-logs/mysql_error.logservice mysql start mysql已正常启动，可以使用mysql/bin目录下的mysql和之前记录的默认密码登录mysql为root账户设置密码1alter user 'root'@'localhost' identified by 'root'; 把mysql注册成开机启动的服务1chkconfig --add mysql 加入环境变量修改/etc/profile文件使其永久性生效，并对所有系统用户生效，在文件末尾加上如下两行代码PATH=$PATH:/home/mysql/mysql:/home/mysql/mysql/binexport PATH最后：执行 命令source /etc/profile或 执行点命令 ./profile使其修改生效，执行完可通过echo $PATH命令查看是否添加成功。 配置账户登录mysql配置一个可以远程访问的账户12GRANT ALL PRIVILEGES ON *.* TO 'myuser'@'%'IDENTIFIED BY 'myuser' WITH GRANT OPTION;FLUSH PRIVILEGES 暂时关闭防火墙，否则外面访问不了systemctl stop firewalld.service 使用Navicat连接mysql使用账户myuser 密码 myuser登录，第一次登录没有成功，在本地用myuser登录一下mysql就可以用navicat连接上了。 今天最好的表现，是明天最低的要求。","categories":[{"name":"linux","slug":"linux","permalink":"https://Gengry.github.io/categories/linux/"},{"name":"mysql","slug":"linux/mysql","permalink":"https://Gengry.github.io/categories/linux/mysql/"}],"tags":[]},{"title":"虚拟机安装Centos，安装mysql，配置主从（一）","slug":"虚拟机安装Centos，安装mysql，配置主从（一）","date":"2018-02-05T05:20:59.000Z","updated":"2018-03-26T06:22:37.396Z","comments":true,"path":"2018/02/05/虚拟机安装Centos，安装mysql，配置主从（一）/","link":"","permalink":"https://Gengry.github.io/2018/02/05/虚拟机安装Centos，安装mysql，配置主从（一）/","excerpt":"前言公司线上使用阿里云的mysql数据库，一直是单点，也是系统中最大的瓶颈。因为开始考虑的是单点，所以第一个负责人将RDS的配置设置的很高，造成了特别大的资源浪费。平时cpu的内存的使用率都特别低。现在的负责人觉得RDS高配置很浪费，做了降配处理，春节前活动直接被查询宕机。所以现在需要考虑优化方案","text":"前言公司线上使用阿里云的mysql数据库，一直是单点，也是系统中最大的瓶颈。因为开始考虑的是单点，所以第一个负责人将RDS的配置设置的很高，造成了特别大的资源浪费。平时cpu的内存的使用率都特别低。现在的负责人觉得RDS高配置很浪费，做了降配处理，春节前活动直接被查询宕机。所以现在需要考虑优化方案 方案一直接使用阿里云的RDS配置主从，RDS自动支持读写分离，简单易用，能用钱解决的问题都是小问题，暂定也是使用这个方案。 方案二使用阿里云的ECS自己搭建mysql的集群。配置mysql读写分离，高可用，防止单点故障造成直接宕机。虽然定的方案是使用RDS，但是我还是在本地搭建一下这个环境，以备不时之需。 安装VMware此步骤略过。 安装Centos下载Centos的ISO包，但是官网的速度简直是巨慢无比无法忍受，可以在中国的镜像站下载。可以从我的博客国内开源镜像站获取开源镜像站推荐使用中国科学技术大学。页面中可以Ctrl+f搜索centos快速定位。在文件目录下找到centos官方推荐使用的最新版本。CentOS7 CentOS-7-x86_64-DVD-1708.iso 标准安装版，一般下载这个就可以了CentOS-7-x86_64-NetInstall-1708.iso 网络安装镜像CentOS-7-x86_64-Everything-1708.iso 对完整版安装盘的软件进行补充，集成所有软件。CentOS-7-x86_64-LiveGNOME-1708.iso GNOME桌面版CentOS-7-x86_64-LiveKDE-1708.iso KDE桌面版CCentOS-7-x86_64-LiveKDE-1708-livecd.iso 光盘上运行的系统，类拟于winpe 安装新手最简单安装一路继续，安装成功后登陆。配置网络，在安装完虚拟就后一般会自动生成两个网络适配器，这个可以删除也可以自定义，但是本次我们使用默认生成的VMware Network Adapter VMnet8现在需要将可以上网的网卡的网络共享给虚拟机的网络适配器。现在看VMware Network Adapter VMnet8的属性，可以看到为他生成了ip地址。根据这个信息配置，虚拟机的虚拟网络（编辑-&gt;虚拟网络编辑器） 配置虚拟机启动默认网络是不自动开启的，编辑网络的配置文件重启network服务，已经获取到ip地址，测试实体机可以ping通。开启ssh外网连接。重启centos。使用xshell连接。 http://blog.csdn.net/bao19901210/article/details/51917641http://blog.csdn.net/u012961566/article/details/70237548http://blog.csdn.net/djcode/article/details/78621772 今天最好的表现，是明天最低的要求。","categories":[{"name":"linux","slug":"linux","permalink":"https://Gengry.github.io/categories/linux/"},{"name":"mysql","slug":"linux/mysql","permalink":"https://Gengry.github.io/categories/linux/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://Gengry.github.io/tags/mysql/"}]},{"title":"SpringMVC hibernate-validator校验请求参数","slug":"SpringMVC hibernate-validator校验请求参数","date":"2018-02-03T07:04:51.000Z","updated":"2018-03-26T06:22:37.395Z","comments":true,"path":"2018/02/03/SpringMVC hibernate-validator校验请求参数/","link":"","permalink":"https://Gengry.github.io/2018/02/03/SpringMVC hibernate-validator校验请求参数/","excerpt":"By default use of @EnableWebMvc or automatically registers Bean Validation support in Spring MVC through the LocalValidatorFactoryBean when a Bean Validation provider such as Hibernate Validator is detected on the classpath.","text":"By default use of @EnableWebMvc or automatically registers Bean Validation support in Spring MVC through the LocalValidatorFactoryBean when a Bean Validation provider such as Hibernate Validator is detected on the classpath. 注意 需要检验的bean需要被 context:component-scan 扫描到 如果不指定校验器，classpath内有hibernate validoter，spring会默认使用它。 1234567891011@ApiOperation(value=\"提交商城订单\",tags=\"商城\")@Auth@RequestMapping(value = \"/submitMallOrder\",method=RequestMethod.POST)@ResponseBodypublic Object submitMallOrder(@RequestBody @Valid MallOrderInfosVO mallOrderInfoVO, BindingResult binding) &#123; if(binding.hasErrors())&#123; return ResultMessage.getValidFail(new HashMap&lt;String,Object&gt;()).setBindingResult(binding); &#125; Map&lt;String,Object&gt; result = mallOrderInfoService.submitMallOrder(mallOrderInfoVO); return ResultMessage.newInstance().setCode(MapUtils.getInteger(result, \"code\")).setMessage(MapUtils.getString(result, \"message\")).setData(MapUtils.getObject(result, \"data\"));&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.jsz.peini.bean.mall;import java.math.BigDecimal;import java.util.ArrayList;import java.util.List;import javax.validation.Valid;import javax.validation.constraints.DecimalMin;import javax.validation.constraints.NotNull;import javax.validation.constraints.Size;import org.hibernate.validator.constraints.Range;import io.swagger.annotations.ApiModelProperty;public class MallOrderInfosVO &#123; @NotNull @Size(min=1) @Valid @ApiModelProperty(\"商城订单列表\") public ArrayList&lt;MallSellerOrderInfoVo&gt; sellerOrderInfoVos; @NotNull @DecimalMin(\"0.00\") @ApiModelProperty(\"订单总额\") public BigDecimal totalMoney; // @NotNull// @Range(min=1,max=3)// @ApiModelProperty(\"支付方式 0金币；1微信；2支付宝\")// public Integer payType; @ApiModelProperty(\"如果是通过购物车提交的订单，传过来购物车的id\") public List&lt;Integer&gt; mallShopCartIds; @NotNull @ApiModelProperty(\"收货地址id\") public Integer mallAddressId; public ArrayList&lt;MallSellerOrderInfoVo&gt; getSellerOrderInfoVos() &#123; return sellerOrderInfoVos; &#125; public void setSellerOrderInfoVos(ArrayList&lt;MallSellerOrderInfoVo&gt; sellerOrderInfoVos) &#123; this.sellerOrderInfoVos = sellerOrderInfoVos; &#125; public BigDecimal getTotalMoney() &#123; return totalMoney; &#125; public void setTotalMoney(BigDecimal totalMoney) &#123; this.totalMoney = totalMoney; &#125;// public Integer getPayType() &#123;// return payType;// &#125;//// public void setPayType(Integer payType) &#123;// this.payType = payType;// &#125; public List&lt;Integer&gt; getMallShopCartIds() &#123; return mallShopCartIds; &#125; public void setMallShopCartIds(List&lt;Integer&gt; mallShopCartIds) &#123; this.mallShopCartIds = mallShopCartIds; &#125; public Integer getMallAddressId() &#123; return mallAddressId; &#125; public void setMallAddressId(Integer mallAddressId) &#123; this.mallAddressId = mallAddressId; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172package com.jsz.peini.bean.mall;import java.math.BigDecimal;import java.util.ArrayList;import javax.validation.Valid;import javax.validation.constraints.DecimalMin;import javax.validation.constraints.Min;import javax.validation.constraints.NotNull;import javax.validation.constraints.Size;import org.hibernate.validator.constraints.Length;import org.hibernate.validator.constraints.Range;import io.swagger.annotations.ApiModelProperty;public class MallSellerOrderInfoVo &#123; @NotNull @ApiModelProperty(\"店铺id\") private Integer sellerId; @NotNull @DecimalMin(\"0.00\") @ApiModelProperty(\"金额合计\") private BigDecimal totalMoney; @NotNull @DecimalMin(\"0.00\") @ApiModelProperty(\"商品总价\") private BigDecimal goodsMoney; @NotNull @DecimalMin(\"0\") @ApiModelProperty(\"支付金额\") private BigDecimal payMoney; @NotNull @DecimalMin(\"0\") @ApiModelProperty(\"快递费用\") private BigDecimal expressPrice; @NotNull @DecimalMin(\"0\") @ApiModelProperty(\"积分补贴\") private BigDecimal scoreMoney; @NotNull @DecimalMin(\"0\") @ApiModelProperty(\"积分消耗\") private Integer scoreUse; @NotNull @Min(1) @ApiModelProperty(\"购买件数\") private Integer buyNum; @NotNull @Range(min=0,max=3) @ApiModelProperty(\"发票类型 0:不要发票 1:个人 2:企业 \") private Integer invoiceType; @Length(max=200) @ApiModelProperty(\"发票抬头\") private String invoiceTitle; @Length(max=200) @ApiModelProperty(\"留言\") private String leaveMsg; @NotNull @ApiModelProperty(\"收货人\") private String receiveUser; @NotNull @ApiModelProperty(\"收货电话\") private String receiveTel; @Length(max=200) @NotNull @ApiModelProperty(\"收货地址\") private String receiveAddress; @Size(min=1) @ApiModelProperty(\"商品订单列表\") @Valid private ArrayList&lt;MallGoodsOrderInfoVO&gt; mallGoodsOrderInfoVOs; public Integer getSellerId() &#123; return sellerId; &#125; public void setSellerId(Integer sellerId) &#123; this.sellerId = sellerId; &#125; public BigDecimal getTotalMoney() &#123; return totalMoney; &#125; public void setTotalMoney(BigDecimal totalMoney) &#123; this.totalMoney = totalMoney; &#125; public BigDecimal getPayMoney() &#123; return payMoney; &#125; public void setPayMoney(BigDecimal payMoney) &#123; this.payMoney = payMoney; &#125; public BigDecimal getExpressPrice() &#123; return expressPrice; &#125; public void setExpressPrice(BigDecimal expressPrice) &#123; this.expressPrice = expressPrice; &#125; public BigDecimal getScoreMoney() &#123; return scoreMoney; &#125; public void setScoreMoney(BigDecimal scoreMoney) &#123; this.scoreMoney = scoreMoney; &#125; public Integer getScoreUse() &#123; return scoreUse; &#125; public void setScoreUse(Integer scoreUse) &#123; this.scoreUse = scoreUse; &#125; public Integer getBuyNum() &#123; return buyNum; &#125; public void setBuyNum(Integer buyNum) &#123; this.buyNum = buyNum; &#125; public Integer getInvoiceType() &#123; return invoiceType; &#125; public void setInvoiceType(Integer invoiceType) &#123; this.invoiceType = invoiceType; &#125; public String getInvoiceTitle() &#123; return invoiceTitle; &#125; public void setInvoiceTitle(String invoiceTitle) &#123; this.invoiceTitle = invoiceTitle; &#125; public String getLeaveMsg() &#123; return leaveMsg; &#125; public void setLeaveMsg(String leaveMsg) &#123; this.leaveMsg = leaveMsg; &#125; public String getReceiveUser() &#123; return receiveUser; &#125; public void setReceiveUser(String receiveUser) &#123; this.receiveUser = receiveUser; &#125; public String getReceiveTel() &#123; return receiveTel; &#125; public void setReceiveTel(String receiveTel) &#123; this.receiveTel = receiveTel; &#125; public String getReceiveAddress() &#123; return receiveAddress; &#125; public void setReceiveAddress(String receiveAddress) &#123; this.receiveAddress = receiveAddress; &#125; public ArrayList&lt;MallGoodsOrderInfoVO&gt; getMallGoodsOrderInfoVOs() &#123; return mallGoodsOrderInfoVOs; &#125; public void setMallGoodsOrderInfoVOs(ArrayList&lt;MallGoodsOrderInfoVO&gt; mallGoodsOrderInfoVOs) &#123; this.mallGoodsOrderInfoVOs = mallGoodsOrderInfoVOs; &#125; public BigDecimal getGoodsMoney() &#123; return goodsMoney; &#125; public void setGoodsMoney(BigDecimal goodsMoney) &#123; this.goodsMoney = goodsMoney; &#125; &#125; 一个完整实例http://blog.csdn.net/vbirdbest/article/details/72620957 今天最好的表现，是明天最低的要求。","categories":[{"name":"spring","slug":"spring","permalink":"https://Gengry.github.io/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://Gengry.github.io/tags/spring/"}]},{"title":"Mysql主从架构读写分离","slug":"Mysql主从架构读写分离","date":"2018-02-02T06:15:32.000Z","updated":"2018-03-26T06:22:37.394Z","comments":true,"path":"2018/02/02/Mysql主从架构读写分离/","link":"","permalink":"https://Gengry.github.io/2018/02/02/Mysql主从架构读写分离/","excerpt":"","text":"百度云：11.高性能必学之Mysql主从架构实践主从配置http://blog.csdn.net/u012961566/article/details/70237548 http://blog.csdn.net/djcode/article/details/78621772 读写分离 mybatis插件https://gitee.com/qiangzigege/MyRWSplit mysql半同步方案 今天最好的表现，是明天最低的要求。","categories":[{"name":"mysql","slug":"mysql","permalink":"https://Gengry.github.io/categories/mysql/"}],"tags":[]},{"title":"JDK动态代理引发的Spring事物不能回滚原因分析","slug":"JDK动态代理引发的Spring事物不能回滚原因分析","date":"2018-02-02T01:59:52.000Z","updated":"2018-03-26T06:22:37.394Z","comments":true,"path":"2018/02/02/JDK动态代理引发的Spring事物不能回滚原因分析/","link":"","permalink":"https://Gengry.github.io/2018/02/02/JDK动态代理引发的Spring事物不能回滚原因分析/","excerpt":"","text":"12.架构师不得不知道的Spring事物不能回滚的深层次原因https://pan.baidu.com/mbox/streampage?from_uk=684610632&amp;msg_id=8376247896642219120&amp;fs_id=476303219573352&amp;to=763122753997696274&amp;type=2&amp;name=12.%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Spring%E4%BA%8B%E7%89%A9%E4%B8%8D%E8%83%BD%E5%9B%9E%E6%BB%9A%E7%9A%84%E6%B7%B1%E5%B1%82%E6%AC%A1%E5%8E%9F%E5%9B%A0.mp4&amp;path=%2FB12%E3%80%81%E9%9D%A2%E8%AF%95%E4%B8%93%E5%B1%9E%2F12.%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Spring%E4%BA%8B%E7%89%A9%E4%B8%8D%E8%83%BD%E5%9B%9E%E6%BB%9A%E7%9A%84%E6%B7%B1%E5%B1%82%E6%AC%A1%E5%8E%9F%E5%9B%A0%2F12.%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Spring%E4%BA%8B%E7%89%A9%E4%B8%8D%E8%83%BD%E5%9B%9E%E6%BB%9A%E7%9A%84%E6%B7%B1%E5%B1%82%E6%AC%A1%E5%8E%9F%E5%9B%A0.mp4&amp;md5=53444f5643355dab35b28dabd3e0b0f1https://www.cnblogs.com/hanxue53/p/5280099.htmlhttps://www.cnblogs.com/doudouxiaoye/p/5789282.htmlhttps://www.cnblogs.com/puyangsky/p/6661638.html 今天最好的表现，是明天最低的要求。","categories":[{"name":"java","slug":"java","permalink":"https://Gengry.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://Gengry.github.io/categories/java/spring/"}],"tags":[]},{"title":"Spring事物源码分析","slug":"Spring事物源码分析","date":"2018-02-01T09:11:52.000Z","updated":"2018-03-26T06:22:37.393Z","comments":true,"path":"2018/02/01/Spring事物源码分析/","link":"","permalink":"https://Gengry.github.io/2018/02/01/Spring事物源码分析/","excerpt":"","text":"https://www.cnblogs.com/lcxdever/p/4570090.htmlhttp://www.cnblogs.com/lcxdever/p/4579126.htmlhttp://www.cnblogs.com/lcxdever/p/4579240.html 今天最好的表现，是明天最低的要求。","categories":[{"name":"spring","slug":"spring","permalink":"https://Gengry.github.io/categories/spring/"}],"tags":[]},{"title":"Mybatis返回Map带null值","slug":"Mybatis返回Map带null值","date":"2018-01-31T01:58:53.000Z","updated":"2018-03-26T06:22:37.392Z","comments":true,"path":"2018/01/31/Mybatis返回Map带null值/","link":"","permalink":"https://Gengry.github.io/2018/01/31/Mybatis返回Map带null值/","excerpt":"前言为客户端提供api接口，返回json数据，规定好了返回的字段，但是当使用Mybatis时如果使用map作为返回值，如果数据库中的值为null，则不会在map中生成对应的key。有的时候一些必要的字段，想要添加上这些key需要使用实体bean作为返回值，但是很多时候，表中的字段很多，很多业务务求只需要部分字段，用表生成bean不适用，单独定义一个bean又嫌麻烦，用map需要在查询之后再补key，很难受。今天看mybatis官方文档，突然看到一个设置，用来解决这个问题。没事多看看官方文档，会有意想不到的收获。","text":"前言为客户端提供api接口，返回json数据，规定好了返回的字段，但是当使用Mybatis时如果使用map作为返回值，如果数据库中的值为null，则不会在map中生成对应的key。有的时候一些必要的字段，想要添加上这些key需要使用实体bean作为返回值，但是很多时候，表中的字段很多，很多业务务求只需要部分字段，用表生成bean不适用，单独定义一个bean又嫌麻烦，用map需要在查询之后再补key，很难受。今天看mybatis官方文档，突然看到一个设置，用来解决这个问题。没事多看看官方文档，会有意想不到的收获。 配置Mybatis官方文档 Mybatis官方文档的目录结构很清楚，我们本次需要关注的是 Configuration XML中的setting callSettersOnNullsSpecifies if setters or map’s put method will be called when a retrieved value is null. It is useful when you rely on Map.keySet() or null value initialization. Note primitives such as (int,boolean,etc.) will not be set to null.true | false默认 false XML配置1234567891011121314151617&lt;!-- mybatis configuration --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"callSettersOnNulls\" value=\"true\"/&gt; &lt;!-- 配置属性值为true--&gt; &lt;/settings&gt;&lt;plugins&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageHelper\"&gt; &lt;property name=\"dialect\" value=\"mysql\" /&gt; &lt;property name=\"rowBoundsWithCount\" value=\"true\"/&gt; &lt;property name=\"pageSizeZero\" value=\"true\" /&gt; &lt;property name=\"reasonable\" value=\"false\" /&gt; &lt;/plugin&gt;&lt;/plugins&gt;&lt;/configuration&gt; 1234567&lt;!--spring configuration xml--&gt; &lt;bean id=\"sessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"configLocation\" value=\"classpath:spring-mybatis.xml\" /&gt; &lt;property name=\"mapperLocations\" value=\"classpath*:com/***/***/mapping/*/*.xml\" /&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.***.bean\" /&gt; &lt;/bean&gt; java配置mybatis配置文件中的set属性其实对应的是org.apache.ibatis.session.Configuration中的变量。例如：1234567891011protected boolean safeRowBoundsEnabled;protected boolean safeResultHandlerEnabled = true;protected boolean mapUnderscoreToCamelCase;protected boolean aggressiveLazyLoading;protected boolean multipleResultSetsEnabled = true;protected boolean useGeneratedKeys;protected boolean useColumnLabel = true;protected boolean cacheEnabled = true;protected boolean callSettersOnNulls;protected boolean useActualParamName = true;protected boolean returnInstanceForEmptyRow; 12345678910DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();TransactionFactory transactionFactory = new JdbcTransactionFactory();Environment environment = new Environment(\"development\", transactionFactory, dataSource);Configuration configuration = new Configuration(environment);configuration.addMapper(BlogMapper.class);configuration.setCallSettersOnNulls = true;SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); 业务代码12345678@Auth@RequestMapping(value = \"/sdfs\",method= RequestMethod.POST)@ResponseBodypublic Object sdfs ()&#123; List&lt;Map&lt;String,Object&gt;&gt; dd = awardBaseMapper.getUserSignStatuss(); System.out.println(dd); return dd;&#125; 1234public interface AwardBaseMapper &#123; @Select(\"select * from user_sign\") List&lt;Map&lt;String,Object&gt;&gt; getUserSignStatuss();&#125; 123456789101112131415161718192021222324252627282930[ &#123; \"sign_year_week\":4, \"sign_year_day\":23, \"sign_year_month\":0, \"user_id\":\"cfeb266707c94b8a92d00c8c05d8b1f7\", \"sign_week_day\":3, \"award_ticket_id\":null, \"id\":7, \"sign_award\":\"未获取到奖励。\", \"sign_type_index\":1, \"sign_year\":2018, \"award_type\":2, \"sign_time\":\"2018-01-23 16:56:19\" &#125;, &#123; \"sign_year_week\":5, \"sign_year_day\":30, \"sign_year_month\":0, \"user_id\":\"1e11281446b84655813ad08fd9da32a1\", \"sign_week_day\":3, \"award_ticket_id\":-1, \"id\":8, \"sign_award\":null, \"sign_type_index\":1, \"sign_year\":2018, \"award_type\":2, \"sign_time\":\"2018-01-30 09:25:43\" &#125;] 上面可见，返回的json串中已经携带了null值的key。不同版本中的属性差异还是挺大的，官网现在是3.4.6，我用的3.2.6中很多属性就没有，如果需要使用新特性，需要升级mybatis版本。 后记 最后在提醒下，对于map中null值引发的空指针问题，可以很好的用 apache commons包中MapUtils解决，可以减少很多不必要的bug。 给客户端返回的json数据中，数组，集合，字典，对象不要有null值，如果是null需要put一个空HashMap或ArrayList，否则客户端反序列化会异常。 今天最好的表现，是明天最低的要求。","categories":[{"name":"mybatis","slug":"mybatis","permalink":"https://Gengry.github.io/categories/mybatis/"}],"tags":[]},{"title":"生成订单号","slug":"生成订单号","date":"2018-01-30T08:40:02.000Z","updated":"2018-03-26T06:22:37.392Z","comments":true,"path":"2018/01/30/生成订单号/","link":"","permalink":"https://Gengry.github.io/2018/01/30/生成订单号/","excerpt":"生成订单号","text":"生成订单号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186package com.jsz.peini.common.util;import java.math.BigDecimal;import java.text.SimpleDateFormat;import java.util.Date;import java.util.HashMap;import java.util.Map;import java.util.concurrent.atomic.AtomicInteger;/** * * 流水号生成器 * * @version v1.0 * @author wgl * */public class SNUtil &#123; private final static String str62 = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"; private final static int pixLen = 36; private static volatile int pixOne = 0; private static volatile int pixTwo = 0; private static volatile int pixThree = 0; private static volatile int pixFour = 0; private static final AtomicInteger ATOM_INT = new AtomicInteger(0); private static final int MAX_36 = 36 * 36 * 36 * 36; /** * 生成短时间内不会重复的长度为15位的字符串。&lt;br/&gt; * 生成策略为获取自1970年1月1日零时零分零秒至当前时间的毫秒数的16进制字符串值，该字符串值为11位&lt;br/&gt; * 并追加四位\"0-z\"的自增字符串.&lt;br/&gt; * 如果系统时间设置为大于&lt;b&gt;2304-6-27 7:00:26&lt;b/&gt;的时间，将会报错！&lt;br/&gt; * 由于系统返回的毫秒数与操作系统关系很大，所以本方法并不准确。本方法可以保证在系统返回的一个毫秒数内生成36的4次方个（1679616）ID不重复。&lt;br/&gt; * 经过测试：该方法效率 比 create15_2 方法快一倍 * @return 15位短时间不会重复的字符串。&lt;br/&gt; * @since JDK1.6 */ public final static synchronized String create15() &#123; StringBuilder sb = new StringBuilder(15);// 创建一个StringBuilder sb.append(Long.toHexString(System.currentTimeMillis()));// 先添加当前时间的毫秒值的16进制 pixFour++; if (pixFour == pixLen) &#123; pixFour = 0; pixThree++; if (pixThree == pixLen) &#123; pixThree = 0; pixTwo++; if (pixTwo == pixLen) &#123; pixTwo = 0; pixOne++; if (pixOne == pixLen) &#123; pixOne = 0; &#125; &#125; &#125; &#125; return sb.append(str62.charAt(pixOne)).append(str62.charAt(pixTwo)).append(str62.charAt(pixThree)).append(str62.charAt(pixFour)) .toString(); &#125; @SuppressWarnings(\"unused\") public final static String create15_2() &#123; StringBuilder sb = new StringBuilder(15); sb.append(Long.toHexString(System.currentTimeMillis())); ATOM_INT.compareAndSet(MAX_36, 0); String str = longTo36(ATOM_INT.incrementAndGet()); if (str.length() == 1) &#123; sb.append(\"000\").append(str); &#125; else if (str.length() == 2) &#123; sb.append(\"00\").append(str); &#125; else if (str.length() == 3) &#123; sb.append(\"0\").append(str); &#125; else &#123; sb.append(str); &#125; return sb.toString(); &#125; /** * 生成短时间内不会重复的长度为16位的字符串。&lt;br/&gt; * 生成策略为获取自1970年1月1日零时零分零秒至当前时间的毫秒数的16进制字符串值，该字符串值为11位&lt;br/&gt; * 并追加四位\"0-z\"的自增字符串.&lt;br/&gt; * 如果系统时间设置为大于&lt;b&gt;2304-6-27 7:00:26&lt;b/&gt;的时间，将会报错！&lt;br/&gt; * 由于系统返回的毫秒数与操作系统关系很大，所以本方法并不准确。本方法可以保证在系统返回的一个毫秒数内生成36的4次方个（1679616）ID不重复。&lt;br/&gt; * 经过测试：该方法效率 比 create15_2 方法快一倍 * @return 15位短时间不会重复的字符串。&lt;br/&gt; * @since JDK1.6 */ @SuppressWarnings(\"unused\") public final static String create16Years() &#123; StringBuilder sb = new StringBuilder(15); sb.append(new SimpleDateFormat(\"yyMMddHHmmss\").format(new Date())); ATOM_INT.compareAndSet(MAX_36, 0); String str = longTo36(ATOM_INT.incrementAndGet()); if (str.length() == 1) &#123; sb.append(\"000\").append(str); &#125; else if (str.length() == 2) &#123; sb.append(\"00\").append(str); &#125; else if (str.length() == 3) &#123; sb.append(\"0\").append(str); &#125; else &#123; sb.append(str); &#125; return sb.toString(); &#125; /** * 10进制转任意进制 * @param num Long型值 * @param base 转换的进制 * @return 任意进制的字符形式 */ private static final String ten2Any(long num, int base) &#123; StringBuilder sb = new StringBuilder(7); while (num != 0) &#123; sb.append(str62.charAt((int) (num % base))); num /= base; &#125; return sb.reverse().toString(); &#125; /** * 将一个Long 值 转换为 62进制 * @param num * @return */ public static final String longTo62(long num) &#123; return ten2Any(num, 62); &#125; private static final String longTo36(long num) &#123; return ten2Any(num, 36); &#125; public static void main(String[] args) &#123; long begin = System.currentTimeMillis(); int repeat = 0; int times = 10000; Map&lt;String, Object&gt; store = new HashMap&lt;String, Object&gt;(); String no = null; for (int i = 0; i &lt; times; i++) &#123; //no = create15(); //no = create15_2(); no = create16Years(); if(store.containsKey(no))&#123; repeat++; &#125;else&#123; store.put(no, 1); &#125; if(i==times-1)&#123; System.out.println(no); &#125; &#125; long end = System.currentTimeMillis(); System.out.println(\"测试getBigOrderCode 重复概率:\"); System.out.println(\"测试次数:\"+times); System.out.println(\"重复次数:\"+repeat); System.out.println(\"重复概率:\"+( new BigDecimal(repeat).divide(new BigDecimal(times)) ) ); System.out.println(\"测试耗时:\"+(end-begin)); &#125; &#125;class SNTester implements Runnable&#123; static Map&lt;String, Object&gt; store = new HashMap&lt;String, Object&gt;(); int times = 2000; @Override public void run() &#123; Map&lt;String, Object&gt; store = new HashMap&lt;String, Object&gt;(); String no = null; for (int i = 0; i &lt; times; i++) &#123; no = SNUtil.create15(); if(store.containsKey(no))&#123; //repeat++; &#125;else&#123; store.put(no, 1); &#125; if(i==times-1)&#123; System.out.println(no); &#125; &#125; &#125; &#125; 今天最好的表现，是明天最低的要求。","categories":[{"name":"java","slug":"java","permalink":"https://Gengry.github.io/categories/java/"}],"tags":[]},{"title":"Mybatis源码解析优秀博文","slug":"Mybatis源码解析优秀博文","date":"2018-01-30T07:06:48.000Z","updated":"2018-03-26T06:22:37.391Z","comments":true,"path":"2018/01/30/Mybatis源码解析优秀博文/","link":"","permalink":"https://Gengry.github.io/2018/01/30/Mybatis源码解析优秀博文/","excerpt":"http://blog.csdn.net/nmgrd/article/details/54608702http://blog.csdn.net/ashan_li/article/list 通过源码分析MyBatis的缓存http://www.cnblogs.com/fangjian0423/p/mybatis-cache.html Mybatis解析动态sql原理分析http://www.cnblogs.com/fangjian0423/p/mybaits-dynamic-sql-analysis.html MyBatis拦截器原理探究http://www.cnblogs.com/fangjian0423/p/mybatis-interceptor.html","text":"http://blog.csdn.net/nmgrd/article/details/54608702http://blog.csdn.net/ashan_li/article/list 通过源码分析MyBatis的缓存http://www.cnblogs.com/fangjian0423/p/mybatis-cache.html Mybatis解析动态sql原理分析http://www.cnblogs.com/fangjian0423/p/mybaits-dynamic-sql-analysis.html MyBatis拦截器原理探究http://www.cnblogs.com/fangjian0423/p/mybatis-interceptor.html myBatis源码之Configurationhttp://blog.csdn.net/ashan_li/article/details/50379458 MyBatis架构设计及源代码分析系列(一):MyBatis架构http://www.cnblogs.com/mengheng/p/3739610.html 深入理解mybatis原理》 MyBatis的架构设计以及实例分析 《深入理解mybatis原理》 MyBatis事务管理机制 Mybatis3.3.x技术内幕（一）：SqlSession和SqlSessionFactory列传 Mybatis3.3.x技术内幕（二）：动态代理之投鞭断流（自动映射器Mapper的底层实现原理） 初看Mybatis 源码 （三） SQL是怎么执行的 深入了解MyBatis参数 MyBatis直接执行SQL的工具SqlMapper 教你如何开发Mybatis的通用Mapper 偶尔记一下没事看看 - MyBatis工具 Mybatis解析动态sql原理分析 - format mybatis源码阅读心得http://xpenxpen.iteye.com/blog/1508749 Mybatis源代码分析之parsing包http://www.cnblogs.com/sunzhenchao/p/3161093.html Mybatis之reflection包源代码解析（一）http://www.cnblogs.com/sunzhenchao/p/3328053.html mybatis源代码分析之binding包http://www.cnblogs.com/sunzhenchao/archive/2013/05/13/3075854.html Mybatis源码分析之Mapper执行SQL过程（三）http://www.ccblog.cn/88.htm Mybatis源码分析之Cache一级缓存原理（四）http://www.ccblog.cn/89.htm Mybatis源码分析之Cache二级缓存原理 （五）http://www.ccblog.cn/90.htm Mybatis插件原理和PageHelper结合实战分页插件（七）http://www.ccblog.cn/92.htm 如何细粒度地控制你的MyBatis二级缓存(mybatis-enhanced-cache插件实现)http://www.tuicool.com/articles/jqqMbaj http://blog.csdn.net/luanlouis/article/details/41800511?utm_source=tuicool&amp;utm_medium=referral MyBatis缓存源码分析http://www.codeceo.com/article/mybatis-cache.html MyBatis源码分析——Cache接口以及实现http://www.cnblogs.com/jabnih/p/5705640.html MyBatis源码分析——Plugin原理http://www.cnblogs.com/jabnih/p/5656194.html MyBatis源码分析（1）——整体依赖关系图http://www.cnblogs.com/jabnih/p/5656182.html 深入浅出Mybatis-改造Cachehttp://blog.csdn.net/keda8997110/article/details/20908425http://blog.csdn.net/keda8997110/article/details/20908425 MyBatis缓存源码分析http://www.codeceo.com/article/mybatis-cache.htmlhttp://www.codeceo.com/article/mybatis-cache.html Mybatis增强型注解简化SQL语句http://blog.csdn.net/ExcellentYuXiao/article/details/53262928 Mybatis增强型注解简化SQL语句http://blog.csdn.net/ExcellentYuXiao/article/details/53262928 Mybatis3源码分析(11)-Sql解析执行-BoundSql的加载-1http://blog.csdn.net/ashan_li/article/details/50370035 Mybatis解析动态sql原理分析http://www.cnblogs.com/fangjian0423/p/mybaits-dynamic-sql-analysis.html 通过源码分析MyBatis的缓存http://www.cnblogs.com/fangjian0423/p/mybatis-cache.html MyBatis拦截器原理探究http://www.cnblogs.com/fangjian0423/p/mybatis-interceptor.html Mybatis 中$与#的区别http://www.cnblogs.com/hellokitty1/p/6007801.html csdn: pfnie深入理解mybatis原理(一)》 Mybatis初始化机制详解http://blog.csdn.net/pfnie/article/details/51491934 深入了解mybatis参数http://www.bubuko.com/infodetail-1219821.html mybatis之 # 与 $ 区别以及 sql 预编译http://blog.csdn.net/wo541075754/article/details/54292751 http://www.cnblogs.com/slwenyi/p/6393808.html ConcurrentHashMap的锁分段技术http://blog.csdn.net/yansong_8686/article/details/50664351 Zookeeper(2)-Zookeeper可以干什么http://blog.csdn.net/zmx729618/article/details/52709942 http://www.cnblogs.com/slwenyi/p/6393808.html http://blog.csdn.net/yansong_8686/article/details/50664351 http://blog.csdn.net/qq_26562641/article/details/51035189 http://uule.iteye.com/blog/1513976 http://blog.csdn.net/zmx729618/article/details/52709942 AbstractQueuedSynchronizer原理及代码分析http://www.cnblogs.com/noahsark/p/sbstract_queued_synchronizer.html 今天最好的表现，是明天最低的要求。","categories":[{"name":"mybatis","slug":"mybatis","permalink":"https://Gengry.github.io/categories/mybatis/"}],"tags":[]},{"title":"国内开源镜像站","slug":"国内开源镜像站","date":"2018-01-29T07:05:28.000Z","updated":"2018-03-26T06:22:37.391Z","comments":true,"path":"2018/01/29/国内开源镜像站/","link":"","permalink":"https://Gengry.github.io/2018/01/29/国内开源镜像站/","excerpt":"公司类 搜狐开源镜像站：http://mirrors.sohu.com/ 网易开源镜像站：http://mirrors.163.com/ 开源中国：http://mirrors.oschina.net/","text":"公司类 搜狐开源镜像站：http://mirrors.sohu.com/ 网易开源镜像站：http://mirrors.163.com/ 开源中国：http://mirrors.oschina.net/ 首都在线科技股份有限公司：http://mirrors.yun-idc.com/ 阿里云开源镜像：http://mirrors.aliyun.com/ LUPA：http://mirror.lupaworld.com/ 常州贝特康姆软件技术有限公司(原cn99）：http://centos.bitcomm.cn/大学类 中山大学镜像：http://mirror.sysu.edu.cn/ 山东理工大学：http://mirrors.sdutlinux.org/ 哈尔滨工业大学：http://run.hit.edu.cn/ 中国地质大学：http://cugbteam.org/ 大连理工大学：http://mirror.dlut.edu.cn/ 西南林业大学 http://cs3.swfu.edu.cn/cs3guide.html 北京化工大学（仅教育网可以访问），包含 CentOS 镜像：http://ubuntu.buct.edu.cn/ 天津大学：http://mirror.tju.edu.cn/ 西南大学：http://linux.swu.edu.cn/swudownload/Distributions/ 青岛大学：http://mirror.qdu.edu.cn/ 南京师范大学：http://mirrors.njnu.edu.cn/ 大连东软信息学院： http://mirrors.neusoft.edu.cn/ 浙江大学：http://mirrors.zju.edu.cn/ 兰州大学：http://mirror.lzu.edu.cn/ 厦门大学：http://mirrors.xmu.edu.cn/ 北京理工大学：http://mirror.bit.edu.cn (IPv4 only)http://mirror.bit6.edu.cn (IPv6 only) 北京交通大学：http://mirror.bjtu.edu.cn (IPv4 only)http://mirror6.bjtu.edu.cn (IPv6 only)http://debian.bjtu.edu.cn (IPv4+IPv6) 上海交通大学：http://ftp.sjtu.edu.cn/ (IPv4 only)http://ftp6.sjtu.edu.cn (IPv6 only) 清华大学：http://mirrors.tuna.tsinghua.edu.cn/ (IPv4+IPv6)http://mirrors.6.tuna.tsinghua.edu.cn/ (IPv6 only)http://mirrors.4.tuna.tsinghua.edu.cn/ (IPv4 only) 中国科学技术大学：http://mirrors.ustc.edu.cn/ (IPv4+IPv6)http://mirrors4.ustc.edu.cn/http://mirrors6.ustc.edu.cn/ 东北大学：http://mirror.neu.edu.cn/ (IPv4 only)http://mirror.neu6.edu.cn/ (IPv6 only) 华中科技大学：http://mirrors.hust.edu.cn/http://mirrors.hustunique.com/ 电子科技大学：http://ubuntu.uestc.edu.cn/ 电子科大凝聚工作室(Raspbian单一系统镜像) http://raspbian.cnssuestc.org/ 电子科大星辰工作室(少数小众发布版镜像) http://mirrors.stuhome.net/PyPi 镜像 豆瓣：http://pypi.douban.com/ 山东理工大学：http://pypi.sdutlinux.org/ 中山大学：http://mirror.sysu.edu.cn/pypi/ V2EX：http://pypi.v2ex.com/simple/RubyGems 镜像 中山大学：http://mirror.sysu.edu.cn/rubygems/ 山东理工大学：http://ruby.sdutlinux.org/ 淘宝网：http://ruby.taobao.org/npm 镜像 cnpmjs：http://cnpmjs.org/ mysql国内镜像下载网址http://mirrors.sohu.com/mysql/http://mirrors.ustc.edu.cn/mysql-ftp/Downloads/ 今天最好的表现，是明天最低的要求。","categories":[{"name":"优秀网站汇总","slug":"优秀网站汇总","permalink":"https://Gengry.github.io/categories/优秀网站汇总/"}],"tags":[]},{"title":"spring多数据源分布式事物研究","slug":"spring多数据源分布式事物研究","date":"2018-01-28T10:12:51.000Z","updated":"2018-03-26T06:22:37.390Z","comments":true,"path":"2018/01/28/spring多数据源分布式事物研究/","link":"","permalink":"https://Gengry.github.io/2018/01/28/spring多数据源分布式事物研究/","excerpt":"分布式事务XA https://www.cnblogs.com/zengkefu/p/5742617.html 一个简单明了的例子使用的是jdbcTemplatespring boot 多数据源的XA事务(Druid+Atomikos) http://blog.csdn.net/ACMer_AK/article/details/78742148 这两个是一组 从配置多数据源引发的不支持事物到使用atomikos配置支持也是jdbcTemplate的例子https://www.jianshu.com/p/61e8961c6154http://blog.csdn.net/erixhao/article/details/52138760 Spring多数据源分布式事务管理/springmvc+spring+atomikos[jta]+druid+mybatishttp://blog.csdn.net/typa01_kk/article/details/51190147","text":"分布式事务XA https://www.cnblogs.com/zengkefu/p/5742617.html 一个简单明了的例子使用的是jdbcTemplatespring boot 多数据源的XA事务(Druid+Atomikos) http://blog.csdn.net/ACMer_AK/article/details/78742148 这两个是一组 从配置多数据源引发的不支持事物到使用atomikos配置支持也是jdbcTemplate的例子https://www.jianshu.com/p/61e8961c6154http://blog.csdn.net/erixhao/article/details/52138760 Spring多数据源分布式事务管理/springmvc+spring+atomikos[jta]+druid+mybatishttp://blog.csdn.net/typa01_kk/article/details/51190147 mysql 很多文章http://blog.51yip.com/category/mysql 大众点评订单系统分库分表实践https://zhuanlan.zhihu.com/p/24036067Mycat从入门到放弃http://blog.csdn.net/u013235478/article/details/53178657 今天最好的表现，是明天最低的要求。","categories":[{"name":"spring","slug":"spring","permalink":"https://Gengry.github.io/categories/spring/"}],"tags":[]},{"title":"AOP详解","slug":"AOP详解","date":"2018-01-27T01:53:23.000Z","updated":"2018-03-26T06:22:37.389Z","comments":true,"path":"2018/01/27/AOP详解/","link":"","permalink":"https://Gengry.github.io/2018/01/27/AOP详解/","excerpt":"AOP产生原因如果要重用通用功能的话，最常见的面向对象技术是继承（inheritance）或委托（delegation）。但是，如果在整个应用中都使用相同的基类，继承往往会导致一个脆弱的对象体系；而使用委托可能需要对委托对象进行复杂的调用。切面提供了取代继承和委托的另一种可选方案，而且在很多场景下更清晰简洁。在使用面向切面编程时，我们仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要以何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称为切面（aspect）。这样做有两个好处：首先，现在每个关注点都集中于一个地方，而不是分散到多处代码中；其次，服务模块更简洁，因为它们只包含主要关注点（或核心功能）的代码，而次要关注点的代码被转移到切面中了。","text":"AOP产生原因如果要重用通用功能的话，最常见的面向对象技术是继承（inheritance）或委托（delegation）。但是，如果在整个应用中都使用相同的基类，继承往往会导致一个脆弱的对象体系；而使用委托可能需要对委托对象进行复杂的调用。切面提供了取代继承和委托的另一种可选方案，而且在很多场景下更清晰简洁。在使用面向切面编程时，我们仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要以何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称为切面（aspect）。这样做有两个好处：首先，现在每个关注点都集中于一个地方，而不是分散到多处代码中；其次，服务模块更简洁，因为它们只包含主要关注点（或核心功能）的代码，而次要关注点的代码被转移到切面中了。 aspect : 实现公共代码的类 AOP术语通知 Advice通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。它应该应用在某个方法被调用之前？之后？之前和之后都调用？还是只在方法抛出异常时调用？Spring切面可以应用5种类型的通知： 前置通知（Before）：在目标方法被调用之前调用通知功能； 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么； 返回通知（After-returning）：在目标方法成功执行之后调用通知； 异常通知（After-throwing）：在目标方法抛出异常后调用通知； 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。切点 Pointcut 今天最好的表现，是明天最低的要求。","categories":[{"name":"spring","slug":"spring","permalink":"https://Gengry.github.io/categories/spring/"}],"tags":[{"name":"aop","slug":"aop","permalink":"https://Gengry.github.io/tags/aop/"}]},{"title":"数据库事物四大特性以及事物的隔离级别","slug":"数据库事物四大特性以及事物的隔离级别","date":"2018-01-27T00:57:00.000Z","updated":"2018-03-26T06:22:37.390Z","comments":true,"path":"2018/01/27/数据库事物四大特性以及事物的隔离级别/","link":"","permalink":"https://Gengry.github.io/2018/01/27/数据库事物四大特性以及事物的隔离级别/","excerpt":"事物的四大特性ACID原子性 Atomicity 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。","text":"事物的四大特性ACID原子性 Atomicity 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。 一致性 Consistency一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 隔离性 Isolation隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 持久性 Durability持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 并发情况下的问题脏读脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。 不可重复读不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。 虚读(幻读)幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。 Mysql提供的四种事物隔离级别 Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。 Repeatable read (可重复读)：可避免脏读、不可重复读的发生。 Read committed (读已提交)：可避免脏读的发生。 Read uncommitted (读未提交)：最低级别，任何情况都无法保证。 以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。 12345--在MySQL数据库中查看当前事务的隔离级别 select @@tx_isolation;--在MySQL数据库中设置事务的隔离 级别： set [glogal | session] transaction isolation level 隔离级别名称; set tx_isolation=’隔离级别名称;’ 后记：隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。 今天最好的表现，是明天最低的要求。","categories":[{"name":"mysql","slug":"mysql","permalink":"https://Gengry.github.io/categories/mysql/"}],"tags":[{"name":"事物","slug":"事物","permalink":"https://Gengry.github.io/tags/事物/"}]},{"title":"替换hexo默认的markdown生成器","slug":"替换hexo默认的markdown生成器","date":"2018-01-24T07:59:35.000Z","updated":"2018-03-26T06:22:37.389Z","comments":true,"path":"2018/01/24/替换hexo默认的markdown生成器/","link":"","permalink":"https://Gengry.github.io/2018/01/24/替换hexo默认的markdown生成器/","excerpt":"今天最好的表现，是明天最低的要求。 前言hexo官方介绍，支持 GitHub Flavored Markdown 的所有功能。但是生成的一些效果和GitHub风格的并不一样，最令我无法忍受的一点就是，在文本编辑器中插入换行，生成的html中就加入一个&lt;br&gt;但是在页面上我并不期待他换行。","text":"今天最好的表现，是明天最低的要求。 前言hexo官方介绍，支持 GitHub Flavored Markdown 的所有功能。但是生成的一些效果和GitHub风格的并不一样，最令我无法忍受的一点就是，在文本编辑器中插入换行，生成的html中就加入一个&lt;br&gt;但是在页面上我并不期待他换行。 替换markdown生成插件在hexo的插件列表搜索markdown，发现有三个markdown插件。这个插件让hexo使用Markdown-it作为渲染引擎，支持MarkDown，GFM，CommonMark风格。 卸载默认插件1npm un hexo-renderer-marked --save 安装1npm i hexo-renderer-markdown-it --save 简单配置在hexo博客的配置文件中_config.yml添加如下代码12345# Markdown-it config## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki/# markdown: 'zero'# markdown: 'default'markdown: 'commonmark' 我使用的是commonmark。 高级配置12345678910111213141516171819202122# Markdown-it config## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wikimarkdown: render: html: true xhtmlOut: false breaks: true linkify: true typographer: true quotes: '“”‘’' plugins: - markdown-it-abbr - markdown-it-footnote - markdown-it-ins - markdown-it-sub - markdown-it-sup anchors: level: 2 collisionSuffix: 'v' permalink: true permalinkClass: header-anchor permalinkSymbol: ¶ 参考： Hexo 插件指南","categories":[{"name":"hexo","slug":"hexo","permalink":"https://Gengry.github.io/categories/hexo/"}],"tags":[]},{"title":"Java线程安全总结","slug":"Java线程安全总结","date":"2018-01-24T06:37:42.000Z","updated":"2018-03-26T06:22:37.388Z","comments":true,"path":"2018/01/24/Java线程安全总结/","link":"","permalink":"https://Gengry.github.io/2018/01/24/Java线程安全总结/","excerpt":"要认识java线程安全，必须了解两个主要的点：java的内存模型，java的线程同步机制。特别是内存模型，java的线程同步机制很大程度上都是基于内存模型而设定的。后面我还会写java并发包的文章，详细总结如何利用java并发包编写高效安全的多线程并发程序。暂时写得比较仓促，后面会慢慢补充完善。","text":"要认识java线程安全，必须了解两个主要的点：java的内存模型，java的线程同步机制。特别是内存模型，java的线程同步机制很大程度上都是基于内存模型而设定的。后面我还会写java并发包的文章，详细总结如何利用java并发包编写高效安全的多线程并发程序。暂时写得比较仓促，后面会慢慢补充完善。 浅谈java内存模型 不同的平台，内存模型是不一样的，但是jvm的内存模型规范是统一的。其实java的多线程并发问题最终都会反映在java的内存模型上，所谓线程安全无非是要控制多个线程对某个资源的有序访问或修改。总结java的内存模型，要解决两个主要的问题：可见性和有序性。我们都知道计算机有高速缓存的存在，处理器并不是每次处理数据都是取内存的。JVM定义了自己的内存模型，屏蔽了底层平台内存管理细节，对于java开发人员，要清楚在jvm内存模型的基础上，如果解决多线程的可见性和有序性。那么，何谓可见性？ 多个线程之间是不能互相传递数据通信的，它们之间的沟通只能通过共享变量来进行。Java内存模型（JMM）规定了jvm有主内存，主内存是多个线程共享的。当new一个对象的时候，也是被分配在主内存中，每个线程都有自己的工作内存，工作内存存储了主存的某些对象的副本，当然线程的工作内存大小是有限制的。当线程操作某个对象时，执行顺序如下： 从主存复制变量到当前工作内存 (read and load) 执行代码，改变共享变量值 (use and assign) 用工作内存数据刷新主存相关内容 (store and write) JVM规范定义了线程对主存的操作指令：read，load，use，assign，store，write。当一个共享变量在多个线程的工作内存中都有副本时，如果一个线程修改了这个共享变量，那么其他线程应该能够看到这个被修改后的值，这就是多线程的可见性问题。那么，什么是有序性呢 ？线程在引用变量时不能直接从主内存中引用,如果线程工作内存中没有该变量,则会从主内存中拷贝一个副本到工作内存中,这个过程为read-load,完成后线程会引用该副本。当同一线程再度引用该字段时,有可能重新从主存中获取变量副本(read-load-use),也有可能直接引用原来的副本(use),也就是说 read,load,use顺序可以由JVM实现系统决定。线程不能直接为主存中中字段赋值，它会将值指定给工作内存中的变量副本(assign),完成后这个变量副本会同步到主存储区(store-write)，至于何时同步过去，根据JVM实现系统决定.有该字段,则会从主内存中将该字段赋值到工作内存中,这个过程为read-load,完成后线程会引用该变量副本，当同一线程多次重复对字段赋值时,比如： 12for(int i=0;i&lt;10;i++) a++; 线程有可能只对工作内存中的副本进行赋值,只到最后一次赋值后才同步到主存储区，所以assign,store,weite顺序可以由JVM实现系统决定。假设有一个共享变量x，线程a执行x=x+1。从上面的描述中可以知道x=x+1并不是一个原子操作，它的执行过程如下： 从主存中读取变量x副本到工作内存 给x加1 将x加1后的值写回主 存如果另外一个线程b执行x=x-1，执行过程如下： 从主存中读取变量x副本到工作内存 给x减1 将x减1后的值写回主存那么显然，最终的x的值是不可靠的。假设x现在为10，线程a加1，线程b减1，从表面上看，似乎最终x还是为10，但是多线程情况下会有这种情况发生： 线程a从主存读取x副本到工作内存，工作内存中x值为10 线程b从主存读取x副本到工作内存，工作内存中x值为10 线程a将工作内存中x加1，工作内存中x值为11 线程a将x提交主存中，主存中x为11 线程b将工作内存中x值减1，工作内存中x值为9 线程b将x提交到中主存中，主存中x为9同样，x有可能为11，如果x是一个银行账户，线程a存款，线程b扣款，显然这样是有严重问题的，要解决这个问题，必须保证线程a和线程b是有序执行的，并且每个线程执行的加1或减1是一个原子操作。看看下面代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Account &#123;private int balance; public Account(int balance) &#123; this.balance = balance; &#125; public int getBalance() &#123; return balance; &#125; public void add(int num) &#123; balance = balance + num; &#125; public void withdraw(int num) &#123; balance = balance - num; &#125; public static void main(String[] args) throws InterruptedException &#123; Account account = new Account(1000); Thread a = new Thread(new AddThread(account, 20), \"add\"); Thread b = new Thread(new WithdrawThread(account, 20), \"withdraw\"); a.start(); b.start(); a.join(); b.join(); System.out.println(account.getBalance()); &#125; static class AddThread implements Runnable &#123; Account account; int amount; public AddThread(Account account, int amount) &#123; this.account = account; this.amount = amount; &#125; public void run() &#123; for (int i = 0; i &lt; 200000; i++) &#123; account.add(amount); &#125; &#125; &#125; static class WithdrawThread implements Runnable &#123; Account account; int amount; public WithdrawThread(Account account, int amount) &#123; this.account = account; this.amount = amount; &#125; public void run() &#123; for (int i = 0; i &lt; 100000; i++) &#123; account.withdraw(amount); &#125; &#125; &#125; &#125; 第一次执行结果为10200，第二次执行结果为1060，每次执行的结果都是不确定的，因为线程的执行顺序是不可预见的。这是java同步产生的根源，synchronized关键字保证了多个线程对于同步块是互斥的，synchronized作为一种同步手段，解决java多线程的执行有序性和内存可见性，而volatile关键字之解决多线程的内存可见性问题。后面将会详细介绍。 synchronized关键字上面说了，java用synchronized关键字做为多线程并发环境的执行有序性的保证手段之一。当一段代码会修改共享变量，这一段代码成为互斥区或临界区，为了保证共享变量的正确性，synchronized标示了临界区。典型的用法如下： 123synchronized(锁)&#123; 临界区代码 &#125; 为了保证银行账户的安全，可以操作账户的方法如下：1234567public synchronized void add(int num) &#123; balance = balance + num; &#125; public synchronized void withdraw(int num) &#123; balance = balance - num; &#125; 刚才不是说了synchronized的用法是这样的吗：1234synchronized(锁)&#123; 临界区代码 &#125; 那么对于public synchronized void add(int num)这种情况，意味着什么呢？其实这种情况，锁就是这个方法所在的对象。同理，如果方法是public static synchronized void add(int num)，那么锁就是这个方法所在的class。理论上，每个对象都可以做为锁，但一个对象做为锁时，应该被多个线程共享，这样才显得有意义，在并发环境下，一个没有共享的对象作为锁是没有意义的。假如有这样的代码：123456789public class ThreadTest&#123; public void test()&#123; Object lock=new Object(); synchronized (lock)&#123; //do something &#125; &#125; &#125; lock变量作为一个锁存在根本没有意义，因为它根本不是共享对象，每个线程进来都会执行Object lock=new Object();每个线程都有自己的lock，根本不存在锁竞争。 每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列，就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程，当一个被线程被唤醒(notify)后，才会进入到就绪队列，等待cpu的调度。当一开始线程a第一次执行account.add方法时，jvm会检查锁对象account的就绪队列是否已经有线程在等待，如果有则表明account的锁已经被占用了，由于是第一次运行，account的就绪队列为空，所以线程a获得了锁，执行account.add方法。如果恰好在这个时候，线程b要执行account.withdraw方法，因为线程a已经获得了锁还没有释放，所以线程b要进入account的就绪队列，等到得到锁后才可以执行。一个线程执行临界区代码过程如下： 获得同步锁 清空工作内存 从主存拷贝变量副本到工作内存 对这些变量计算 将变量从工作内存写回到主存 释放锁可见，synchronized既保证了多线程的并发有序性，又保证了多线程的内存可见性。 生产者/消费者模式 生产者/消费者模式其实是一种很经典的线程同步模型，很多时候，并不是光保证多个线程对某共享资源操作的互斥性就够了，往往多个线程之间都是有协作的。 假设有这样一种情况，有一个桌子，桌子上面有一个盘子，盘子里只能放一颗鸡蛋，A专门往盘子里放鸡蛋，如果盘子里有鸡蛋，则一直等到盘子里没鸡蛋，B专门从盘子里拿鸡蛋，如果盘子里没鸡蛋，则等待直到盘子里有鸡蛋。其实盘子就是一个互斥区，每次往盘子放鸡蛋应该都是互斥的，A的等待其实就是主动放弃锁，B等待时还要提醒A放鸡蛋。 如何让线程主动释放锁 很简单，调用锁的wait()方法就好。wait方法是从Object来的，所以任意对象都有这个方法。看这个代码片段：1234567Object lock=new Object();//声明了一个对象作为锁 synchronized (lock) &#123; balance = balance - num; //这里放弃了同步锁，好不容易得到，又放弃了 lock.wait(); &#125; 如果一个线程获得了锁lock，进入了同步块，执行lock.wait()，那么这个线程会进入到lock的阻塞队列。如果调用lock.notify()则会通知阻塞队列的某个线程进入就绪队列。声明一个盘子，只能放一个鸡蛋1234567891011121314151617181920212223242526272829package com.jameswxx.synctest; public class Plate&#123; List&lt;Object&gt; eggs=new ArrayList&lt;Object&gt;(); public synchronized Object getEgg()&#123; if(eggs.size()==0)&#123; try&#123; wait(); &#125;catch(InterruptedException e)&#123; &#125; &#125; Object egg=eggs.get(0); eggs.clear();//清空盘子 notify();//唤醒阻塞队列的某线程到就绪队列 return egg; &#125; public synchronized void putEgg(Object egg)&#123; If(eggs.size()&gt;0)&#123; try&#123; wait(); &#125;catch(InterruptedException e)&#123; &#125; &#125; eggs.add(egg);//往盘子里放鸡蛋 notify();//唤醒阻塞队列的某线程到就绪队列 &#125; &#125; 声明一个Plate对象为plate，被线程A和线程B共享，A专门放鸡蛋，B专门拿鸡蛋。假设1 开始，A调用plate.putEgg方法，此时eggs.size()为0，因此顺利将鸡蛋放到盘子，还执行了notify()方法，唤醒锁的阻塞队列的线程，此时阻塞队列还没有线程。2 又有一个A线程对象调用plate.putEgg方法，此时eggs.size()不为0，调用wait()方法，自己进入了锁对象的阻塞队列。3 此时，来了一个B线程对象，调用plate.getEgg方法，eggs.size()不为0，顺利的拿到了一个鸡蛋，还执行了notify()方法，唤醒锁的阻塞队列的线程，此时阻塞队列有一个A线程对象，唤醒后，它进入到就绪队列，就绪队列也就它一个，因此马上得到锁，开始往盘子里放鸡蛋，此时盘子是空的，因此放鸡蛋成功。4 假设接着来了线程A，就重复2；假设来料线程B，就重复3。整个过程都保证了放鸡蛋，拿鸡蛋，放鸡蛋，拿鸡蛋。 volatile关键字 volatile是java提供的一种同步手段，只不过它是轻量级的同步，为什么这么说，因为volatile只能保证多线程的内存可见性，不能保证多线程的执行有序性。而最彻底的同步要保证有序性和可见性，例如synchronized。任何被volatile修饰的变量，都不拷贝副本到工作内存，任何修改都及时写在主存。因此对于Valatile修饰的变量的修改，所有线程马上就能看到，但是volatile不能保证对变量的修改是有序的。什么意思呢？假如有这样的代码：1234567public class VolatileTest&#123; public volatile int a; public void add(int count)&#123; a=a+count; &#125; &#125; 当一个VolatileTest对象被多个线程共享，a的值不一定是正确的，因为a=a+count包含了好几步操作，而此时多个线程的执行是无序的，因为没有任何机制来保证多个线程的执行有序性和原子性。volatile存在的意义是，任何线程对a的修改，都会马上被其他线程读取到，因为直接操作主存，没有线程对工作内存和主存的同步。所以，volatile的使用场景是有限的，在有限的一些情形下可以使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全,必须同时满足下面两个条件: 1)对变量的写操作不依赖于当前值。2)该变量没有包含在具有其他变量的不变式中volatile只保证了可见性，所以Volatile适合直接赋值的场景，如1234567public class VolatileTest&#123; public volatile int a; public void setA(int a)&#123; this.a=a; &#125; &#125; 在没有volatile声明时，多线程环境下，a的最终值不一定是正确的，因为this.a=a;涉及到给a赋值和将a同步回主存的步骤，这个顺序可能被打乱。如果用volatile声明了，读取主存副本到工作内存和同步a到主存的步骤，相当于是一个原子操作。所以简单来说，volatile适合这种场景：一个变量被多个线程共享，线程直接给这个变量赋值。这是一种很简单的同步场景，这时候使用volatile的开销将会非常小。 今天最好的表现，是明天最低的要求。","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://Gengry.github.io/categories/Java并发编程/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://Gengry.github.io/tags/并发/"}]},{"title":"优秀社区、博客、文章汇总","slug":"优秀社区、博客、文章汇总","date":"2018-01-23T01:40:25.000Z","updated":"2018-03-26T06:22:37.387Z","comments":true,"path":"2018/01/23/优秀社区、博客、文章汇总/","link":"","permalink":"https://Gengry.github.io/2018/01/23/优秀社区、博客、文章汇总/","excerpt":"优秀博客徐刘根 http://blog.csdn.net/xlgen157387?viewmode=contents程序员DD http://blog.didispace.com/纯洁的微笑 http://www.ityouknow.com/廖雪峰的官方网站：https://www.liaoxuefeng.com/新栋BOOK（比较偏深入分析）：https://www.jianshu.com/u/f2fa1bce6780","text":"优秀博客徐刘根 http://blog.csdn.net/xlgen157387?viewmode=contents程序员DD http://blog.didispace.com/纯洁的微笑 http://www.ityouknow.com/廖雪峰的官方网站：https://www.liaoxuefeng.com/新栋BOOK（比较偏深入分析）：https://www.jianshu.com/u/f2fa1bce6780特别多文章 http://blog.csdn.net/z69183787阮一峰的网络日志 http://www.ruanyifeng.com/blog/嘟嘟独立博客 http://tengj.top/强子哥哥 https://gitee.com/qiangzigege/projectshttp://blog.battcn.com/ 优秀社区springforall http://www.spring4all.com/ 优秀文章从零开始制作 Hexo 主题 http://www.ahonn.me/2016/12/15/create-a-hexo-theme-from-scratch/Java集合学习1：HashMap的实现原理 http://tracylihui.github.io/2015/07/01/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A01%EF%BC%9AHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/ mysql搭建MySQL高可用负载均衡集群 http://www.cnblogs.com/phpstudy2015-6/p/6706465.htmlspring+mybatis+druid数据源+sharding-jdbc分库分表 http://blog.csdn.net/aitangyong/article/details/53291437Spring Boot MyBatis 动态数据源切换、多数据源，读写分离 http://blog.csdn.net/u013360850/article/details/78861442Spring 配置多个数据源，并实现动态切换 http://blog.csdn.net/gaofuqi/article/details/46417281 Web安全验证理解OAuth 2.0 http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html IOJava NIO：浅析I/O模型 http://www.cnblogs.com/dolphin0520/p/3916526.html百度云 高性能网络编程必备技能之IO与NIO阻塞分析 开源项目小周java技术分享 https://gitee.com/zhoubang85 http://www.2b2b92b.com/ https://gitee.com/zhoubang85/zbJava单点登录权限系统，权限按钮级、修改实时生效、支持分布式 https://github.com/a466350665/smart https://gitee.com/a466350665/smart","categories":[{"name":"优秀网站汇总","slug":"优秀网站汇总","permalink":"https://Gengry.github.io/categories/优秀网站汇总/"}],"tags":[]},{"title":"hexo+github搭建环境","slug":"hexo-github搭建环境","date":"2018-01-23T01:29:27.000Z","updated":"2018-03-26T06:22:37.386Z","comments":true,"path":"2018/01/23/hexo-github搭建环境/","link":"","permalink":"https://Gengry.github.io/2018/01/23/hexo-github搭建环境/","excerpt":"https://www.cnblogs.com/fengxiongZz/p/7707219.html","text":"https://www.cnblogs.com/fengxiongZz/p/7707219.html","categories":[{"name":"hexo","slug":"hexo","permalink":"https://Gengry.github.io/categories/hexo/"}],"tags":[]},{"title":"hexo配合github管理源文件和静态文件","slug":"hexo配合github管理源文件和静态文件","date":"2018-01-22T14:21:55.000Z","updated":"2018-03-26T06:22:37.386Z","comments":true,"path":"2018/01/22/hexo配合github管理源文件和静态文件/","link":"","permalink":"https://Gengry.github.io/2018/01/22/hexo配合github管理源文件和静态文件/","excerpt":"其实，Hexo生成的文件里面是有一个.gitignore的，所以它的本意应该也是想我们把这些文件放到GitHub上存放的。","text":"其实，Hexo生成的文件里面是有一个.gitignore的，所以它的本意应该也是想我们把这些文件放到GitHub上存放的。但是考虑到如果每个GitHub Pages都需要额外的一个仓库存放这些文件，就显得特别冗余了。这个时候就可以用分支的思路！一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。最近我也用GitHub Pages搭建了一个独立博客，想到了这个方法，使用之后真的特别简洁。为了更直观地说明，奉上使用这种方法不同时候的流程：———————————————————– 华丽的分割线1 ———————————————————-一、关于搭建的流程 创建仓库，http://CrazyMilk.github.io； 创建两个分支：master 与 hexo； 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）； 使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库； 在本地http://CrazyMilk.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install和 npm install hexo-deployer-git（此时当前分支应显示为hexo）; 修改_config.yml中的deploy参数，分支应为master； 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件； 执行hexo g -d生成网站并部署到GitHub上。这样一来，在GitHub上的http://CrazyMilk.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美( •̀ ω •́ )y！二、关于日常的改动流程在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理。 依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）； 然后才执行hexo g -d发布网站到master分支上。虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。三、本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： 使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库（默认分支为hexo）； 在本地新拷贝的http://CrazyMilk.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。———————————————————- 华丽的分割线2 ———————————————————-以上就是我采用的方法，虽说文字有点多，但是我个人觉得真的挺高效和简洁的。更详细的可以参考我刚写的博文：GitHub Pages + Hexo搭建博客。第一次回答问题，略紧张呢 ( •̀ ω •́ )y","categories":[{"name":"hexo","slug":"hexo","permalink":"https://Gengry.github.io/categories/hexo/"}],"tags":[]}]}